"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@contentful";
exports.ids = ["vendor-chunks/@contentful"];
exports.modules = {

/***/ "(rsc)/./node_modules/@contentful/content-source-maps/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@contentful/content-source-maps/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SUPPORTED_WIDGETS: () => (/* binding */ ce),\n/* harmony export */   clone: () => (/* binding */ Q),\n/* harmony export */   combine: () => (/* binding */ w),\n/* harmony export */   createSourceMapMetadata: () => (/* binding */ C),\n/* harmony export */   decode: () => (/* binding */ ae),\n/* harmony export */   encode: () => (/* binding */ ie),\n/* harmony export */   encodeCPAResponse: () => (/* binding */ le),\n/* harmony export */   encodeField: () => (/* binding */ P),\n/* harmony export */   encodeGraphQLResponse: () => (/* binding */ fe),\n/* harmony export */   encodeRichTextValue: () => (/* binding */ oe),\n/* harmony export */   isBuiltinNamespace: () => (/* binding */ B),\n/* harmony export */   isSupportedWidget: () => (/* binding */ D),\n/* harmony export */   splitEncoding: () => (/* binding */ ue)\n/* harmony export */ });\nvar W = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, L = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, j = new Array(4).fill(String.fromCodePoint(L[0])).join(\"\"), V = \"\\0\";\nfunction U(t) {\n  let n = JSON.stringify(t);\n  return `${j}${Array.from(n).map((o) => {\n    let e = o.charCodeAt(0);\n    if (e > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${n} on character ${o} (${e})`);\n    return Array.from(e.toString(4).padStart(4, \"0\")).map((r) => String.fromCodePoint(L[r])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction Z(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction q(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch (n) {\n    return !1;\n  }\n  return !0;\n}\nfunction G(t, n, o = \"auto\") {\n  return o === !0 || o === \"auto\" && (Z(t) || q(t)) ? t : `${t}${U(n)}`;\n}\nvar H = Object.fromEntries(Object.entries(L).map((t) => t.reverse())), F = Object.fromEntries(Object.entries(W).map((t) => t.reverse())), K = `${Object.values(W).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, O = new RegExp(`[${K}]{4,}`, \"gu\");\nfunction X(t) {\n  let n = t.match(O);\n  if (n) return Y(n[0], !0)[0];\n}\nfunction Y(t, n = !1) {\n  let o = Array.from(t);\n  if (o.length % 2 === 0) {\n    if (o.length % 4 || !t.startsWith(j)) return ee(o, n);\n  } else throw new Error(\"Encoded data has invalid length\");\n  let e = [];\n  for (let r = o.length * 0.25; r--; ) {\n    let s = o.slice(r * 4, r * 4 + 4).map((c) => H[c.codePointAt(0)]).join(\"\");\n    e.unshift(String.fromCharCode(parseInt(s, 4)));\n  }\n  if (n) {\n    e.shift();\n    let r = e.indexOf(V);\n    return r === -1 && (r = e.length), [JSON.parse(e.slice(0, r).join(\"\"))];\n  }\n  return e.join(\"\").split(V).filter(Boolean).map((r) => JSON.parse(r));\n}\nfunction ee(t, n) {\n  var o;\n  let e = [];\n  for (let i = t.length * 0.5; i--; ) {\n    let u = `${F[t[i * 2].codePointAt(0)]}${F[t[i * 2 + 1].codePointAt(0)]}`;\n    e.unshift(String.fromCharCode(parseInt(u, 16)));\n  }\n  let r = [], s = [e.join(\"\")], c = 10;\n  for (; s.length; ) {\n    let i = s.shift();\n    try {\n      if (r.push(JSON.parse(i)), n) return r;\n    } catch (u) {\n      if (!c--) throw u;\n      let a = +((o = u.message.match(/\\sposition\\s(\\d+)$/)) == null ? void 0 : o[1]);\n      if (!a) throw u;\n      s.unshift(i.substring(0, a), i.substring(a));\n    }\n  }\n  return r;\n}\nfunction te(t) {\n  var n;\n  return { cleaned: t.replace(O, \"\"), encoded: ((n = t.match(O)) == null ? void 0 : n[0]) || \"\" };\n}\nfunction w(t, n) {\n  return G(t, n);\n}\nfunction ie(t) {\n  return U(t);\n}\nfunction ae(t) {\n  return X(t);\n}\nfunction ue(t) {\n  return te(t);\n}\nvar x, k;\nfunction ne() {\n  if (k) return x;\n  k = 1;\n  var t = Object.prototype.hasOwnProperty, n = Object.prototype.toString;\n  return x = function(e, r, s) {\n    if (n.call(r) !== \"[object Function]\")\n      throw new TypeError(\"iterator must be a function\");\n    var c = e.length;\n    if (c === +c)\n      for (var i = 0; i < c; i++)\n        r.call(s, e[i], i, e);\n    else\n      for (var u in e)\n        t.call(e, u) && r.call(s, e[u], u, e);\n  }, x;\n}\nvar I, _;\nfunction re() {\n  if (_) return I;\n  _ = 1;\n  var t = ne();\n  I = n;\n  function n(o, e, r) {\n    if (arguments.length === 3)\n      return n.set(o, e, r);\n    if (arguments.length === 2)\n      return n.get(o, e);\n    var s = n.bind(n, o);\n    for (var c in n)\n      n.hasOwnProperty(c) && (s[c] = n[c].bind(s, o));\n    return s;\n  }\n  return n.get = function(e, r) {\n    for (var s = Array.isArray(r) ? r : n.parse(r), c = 0; c < s.length; ++c) {\n      var i = s[c];\n      if (!(typeof e == \"object\" && i in e))\n        throw new Error(\"Invalid reference token: \" + i);\n      e = e[i];\n    }\n    return e;\n  }, n.set = function(e, r, s) {\n    var c = Array.isArray(r) ? r : n.parse(r), i = c[0];\n    if (c.length === 0)\n      throw Error(\"Can not set the root object\");\n    for (var u = 0; u < c.length - 1; ++u) {\n      var a = c[u];\n      typeof a != \"string\" && typeof a != \"number\" && (a = String(a)), !(a === \"__proto__\" || a === \"constructor\" || a === \"prototype\") && (a === \"-\" && Array.isArray(e) && (a = e.length), i = c[u + 1], a in e || (i.match(/^(\\d+|-)$/) ? e[a] = [] : e[a] = {}), e = e[a]);\n    }\n    return i === \"-\" && Array.isArray(e) && (i = e.length), e[i] = s, this;\n  }, n.remove = function(o, e) {\n    var r = Array.isArray(e) ? e : n.parse(e), s = r[r.length - 1];\n    if (s === void 0)\n      throw new Error('Invalid JSON pointer for remove: \"' + e + '\"');\n    var c = n.get(o, r.slice(0, -1));\n    if (Array.isArray(c)) {\n      var i = +s;\n      if (s === \"\" && isNaN(i))\n        throw new Error('Invalid array index: \"' + s + '\"');\n      Array.prototype.splice.call(c, i, 1);\n    } else\n      delete c[s];\n  }, n.dict = function(e, r) {\n    var s = {};\n    return n.walk(e, function(c, i) {\n      s[i] = c;\n    }, r), s;\n  }, n.walk = function(e, r, s) {\n    var c = [];\n    s = s || function(i) {\n      var u = Object.prototype.toString.call(i);\n      return u === \"[object Object]\" || u === \"[object Array]\";\n    }, function i(u) {\n      t(u, function(a, l) {\n        c.push(String(l)), s(a) ? i(a) : r(a, n.compile(c)), c.pop();\n      });\n    }(e);\n  }, n.has = function(e, r) {\n    try {\n      n.get(e, r);\n    } catch (s) {\n      return !1;\n    }\n    return !0;\n  }, n.escape = function(e) {\n    return e.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n  }, n.unescape = function(e) {\n    return e.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n  }, n.parse = function(e) {\n    if (e === \"\")\n      return [];\n    if (e.charAt(0) !== \"/\")\n      throw new Error(\"Invalid JSON pointer: \" + e);\n    return e.substring(1).split(/\\//).map(n.unescape);\n  }, n.compile = function(e) {\n    return e.length === 0 ? \"\" : \"/\" + e.map(n.escape).join(\"/\");\n  }, I;\n}\nvar p = re();\nconst oe = ({\n  pointer: t,\n  mappings: n,\n  data: o,\n  hiddenStrings: e\n}) => {\n  const r = n[t];\n  if (r) {\n    delete n[t];\n    const s = b(o, t);\n    for (const c of s) {\n      n[c] = r;\n      const i = p.get(o, c), u = w(i, e);\n      p.set(o, c, u);\n    }\n  } else {\n    const s = b(o, t);\n    for (const c of s) {\n      const i = p.get(o, c), u = w(i, e);\n      p.set(o, c, u);\n    }\n  }\n};\nfunction se(t) {\n  return \"content\" in t && !!t.content;\n}\nconst b = (t, n = \"\") => {\n  const o = [], e = p.get(t, n);\n  if (se(e))\n    for (let r = 0; r < e.content.length; r++)\n      e.content[r].nodeType === \"text\" ? o.push(`${n}/content/${r}/value`) : o.push(...b(t, `${n}/content/${r}`));\n  return o;\n}, C = ({\n  entityId: t,\n  entityType: n,\n  space: o,\n  environment: e,\n  field: r,\n  locale: s,\n  editorInterface: c,\n  fieldType: i,\n  targetOrigin: u,\n  platform: a\n}) => {\n  const d = {\n    origin: \"contentful.com\",\n    href: `${`${u || \"https://app.contentful.com\"}/spaces/${o}/environments/${e}`}/${n === \"Entry\" ? \"entries\" : \"assets\"}/${t}/?focusedField=${r}&focusedLocale=${s}&source=vercel-content-link`,\n    contentful: {\n      editorInterface: c,\n      fieldType: i\n    }\n  };\n  return a === \"vercel\" && delete d.contentful, d;\n}, B = (t) => [\"builtin\", \"sidebar-builtin\", \"editor-builtin\"].includes(t), D = (t) => ce.includes(t);\nfunction Q(t) {\n  if (typeof structuredClone == \"function\")\n    return structuredClone(t);\n  try {\n    return JSON.parse(JSON.stringify(t));\n  } catch (n) {\n    return console.warn(\"Failed to clone data:\", t, n), t;\n  }\n}\nconst ce = [\n  \"singleLine\",\n  \"tagEditor\",\n  \"listInput\",\n  \"checkbox\",\n  \"richTextEditor\",\n  \"multipleLine\"\n];\nfunction P(t, n, o, e, r, s, c) {\n  const i = c ? n[c] : n;\n  switch (t) {\n    case \"Symbol\": {\n      const u = w(i, o);\n      p.set(e, r, u);\n      break;\n    }\n    case \"Text\": {\n      const u = w(i, o);\n      p.set(e, r, u);\n      break;\n    }\n    case \"RichText\": {\n      oe({\n        pointer: \"\",\n        mappings: s,\n        data: i,\n        hiddenStrings: o\n      });\n      break;\n    }\n    case \"Array\": {\n      const u = i.map((a) => typeof a == \"string\" ? w(a, o) : a);\n      p.set(e, r, u);\n      break;\n    }\n  }\n}\nconst fe = (t, n, o) => {\n  if (!t || !t.extensions || !t.extensions.contentSourceMaps)\n    return console.error(\n      \"GraphQL response does not contain Content Source Maps information.\",\n      t\n    ), t;\n  const e = Q(t), {\n    spaces: r,\n    environments: s,\n    editorInterfaces: c,\n    fields: i,\n    locales: u,\n    entries: a,\n    assets: l,\n    mappings: m,\n    fieldTypes: v\n  } = e.extensions.contentSourceMaps, y = e;\n  for (const d in m) {\n    const { source: f } = m[d], h = \"entry\" in f ? a[f.entry] : l[f.asset], M = \"entry\" in f ? \"Entry\" : \"Asset\";\n    if (!h)\n      return e;\n    const g = r[h.space], A = s[h.environment], E = h.id, S = i[f.field], T = u[f.locale], N = c[f.editorInterface], J = v[f.fieldType];\n    if (!(B(N.widgetNamespace) && !D(N.widgetId)) && p.has(y, d)) {\n      const R = p.get(y, d);\n      if (R !== null) {\n        const z = C({\n          entityId: E,\n          entityType: M,\n          space: g,\n          environment: A,\n          field: S,\n          locale: T,\n          editorInterface: N,\n          fieldType: J,\n          targetOrigin: n,\n          platform: o\n        });\n        P(J, R, z, y, d, m);\n      }\n    }\n  }\n  return e;\n}, $ = (t, n, o, e, r) => {\n  if (!t.fields)\n    return;\n  const { contentSourceMaps: s } = t.sys;\n  if (!s)\n    return;\n  const { mappings: c } = s;\n  for (const i in c) {\n    const { source: u } = c[i], a = t.sys.space.sys.id, l = t.sys.environment.sys.id, m = t.sys.id, v = t.sys.type, y = n[u.fieldType], d = o[u.editorInterface];\n    if (B(d.widgetNamespace) && !D(d.widgetId))\n      continue;\n    const f = i.startsWith(\"/\") ? i : `/${i}`;\n    if (p.has(t, f)) {\n      const h = p.get(t, f);\n      if (h === null)\n        return;\n      const g = f.split(\"/\").pop();\n      if (!g) {\n        console.error(\"Field name could not be extracted from the pointer\", f);\n        return;\n      }\n      const A = t.sys.locale;\n      if (A) {\n        const E = C({\n          entityId: m,\n          entityType: v,\n          space: a,\n          environment: l,\n          field: g,\n          locale: A,\n          editorInterface: d,\n          fieldType: y,\n          targetOrigin: e,\n          platform: r\n        });\n        P(y, h, E, t, f, c);\n      } else\n        Object.keys(h).forEach((S) => {\n          const T = C({\n            entityId: m,\n            entityType: v,\n            space: a,\n            environment: l,\n            field: g,\n            locale: S,\n            editorInterface: d,\n            fieldType: y,\n            targetOrigin: e,\n            platform: r\n          });\n          P(\n            y,\n            h,\n            T,\n            t,\n            `${f}/${S}`,\n            c,\n            S\n          );\n        });\n    }\n  }\n}, le = (t, n, o) => {\n  var r;\n  const e = Q(\n    t\n  );\n  if (e.sys && \"items\" in e) {\n    const s = e;\n    if (!((r = s.sys) != null && r.contentSourceMapsLookup))\n      return s;\n    const {\n      contentSourceMapsLookup: { fieldTypes: c, editorInterfaces: i }\n    } = s.sys, { items: u, includes: a } = s;\n    u.forEach(\n      (l) => $(l, c, i, n, o)\n    ), a && a.Entry && a.Entry.forEach(\n      (l) => $(l, c, i, n, o)\n    ), a && a.Asset && a.Asset.forEach(\n      (l) => $(l, c, i, n, o)\n    );\n  } else {\n    const s = e;\n    if (!s.sys.contentSourceMapsLookup)\n      return console.error(\"Content source maps lookup data is missing\"), s;\n    $(\n      s,\n      s.sys.contentSourceMapsLookup.fieldTypes,\n      s.sys.contentSourceMapsLookup.editorInterfaces,\n      n,\n      o\n    );\n  }\n  return e;\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvbnRlbnRmdWwvY29udGVudC1zb3VyY2UtbWFwcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxVQUFVLGlLQUFpSyxRQUFRLHFDQUFxQztBQUN4TjtBQUNBO0FBQ0EsWUFBWSxFQUFFLEVBQUU7QUFDaEI7QUFDQSxvR0FBb0csR0FBRyxlQUFlLEdBQUcsR0FBRyxFQUFFO0FBQzlIO0FBQ0EsR0FBRyxXQUFXO0FBQ2Q7QUFDQTtBQUNBLDRFQUE0RSxFQUFFLHFCQUFxQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRSxFQUFFLEtBQUs7QUFDdEU7QUFDQSxpSkFBaUosaUNBQWlDLEVBQUUsZ0JBQWdCLFlBQVksc0JBQXNCLEVBQUUsRUFBRSxHQUFHO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDLGVBQWUsMkJBQTJCLEVBQUUsK0JBQStCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0Esa1FBQWtRO0FBQ2xRO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyxtREFBbUQsRUFBRSxXQUFXLEVBQUUsNkJBQTZCLEVBQUUsV0FBVyxFQUFFO0FBQzlHO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxhQUFhLEdBQUcsa0NBQWtDLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLEdBQUcscUNBQXFDLEdBQUcsRUFBRSxpQkFBaUIsRUFBRSxpQkFBaUIsRUFBRTtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRSxHQUFHLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLE1BQU0sV0FBVyx3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdXNlci9EZXNrdG9wL3BvcnRzbW91dGgvbm9kZV9tb2R1bGVzL0Bjb250ZW50ZnVsL2NvbnRlbnQtc291cmNlLW1hcHMvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVyA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogODI5MCwgNDogODI5MSwgNTogODI4OCwgNjogNjUyNzksIDc6IDgyODksIDg6IDExOTE1NSwgOTogMTE5MTU2LCBhOiAxMTkxNTcsIGI6IDExOTE1OCwgYzogMTE5MTU5LCBkOiAxMTkxNjAsIGU6IDExOTE2MSwgZjogMTE5MTYyIH0sIEwgPSB7IDA6IDgyMDMsIDE6IDgyMDQsIDI6IDgyMDUsIDM6IDY1Mjc5IH0sIGogPSBuZXcgQXJyYXkoNCkuZmlsbChTdHJpbmcuZnJvbUNvZGVQb2ludChMWzBdKSkuam9pbihcIlwiKSwgViA9IFwiXFwwXCI7XG5mdW5jdGlvbiBVKHQpIHtcbiAgbGV0IG4gPSBKU09OLnN0cmluZ2lmeSh0KTtcbiAgcmV0dXJuIGAke2p9JHtBcnJheS5mcm9tKG4pLm1hcCgobykgPT4ge1xuICAgIGxldCBlID0gby5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChlID4gMjU1KSB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgQVNDSUkgZWRpdCBpbmZvIGNhbiBiZSBlbmNvZGVkLiBFcnJvciBhdHRlbXB0aW5nIHRvIGVuY29kZSAke259IG9uIGNoYXJhY3RlciAke299ICgke2V9KWApO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGUudG9TdHJpbmcoNCkucGFkU3RhcnQoNCwgXCIwXCIpKS5tYXAoKHIpID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KExbcl0pKS5qb2luKFwiXCIpO1xuICB9KS5qb2luKFwiXCIpfWA7XG59XG5mdW5jdGlvbiBaKHQpIHtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4oTnVtYmVyKHQpKSB8fCAvW2Etel0vaS50ZXN0KHQpICYmICEvXFxkKyg/OlstOlxcL11cXGQrKXsyfSg/OlRcXGQrKD86Wy06XFwvXVxcZCspezEsMn0oXFwuXFxkKyk/Wj8pPy8udGVzdCh0KSA/ICExIDogISFEYXRlLnBhcnNlKHQpO1xufVxuZnVuY3Rpb24gcSh0KSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh0LCB0LnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJodHRwczovL2FjbWUuY29tXCIgOiB2b2lkIDApO1xuICB9IGNhdGNoIChuKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIEcodCwgbiwgbyA9IFwiYXV0b1wiKSB7XG4gIHJldHVybiBvID09PSAhMCB8fCBvID09PSBcImF1dG9cIiAmJiAoWih0KSB8fCBxKHQpKSA/IHQgOiBgJHt0fSR7VShuKX1gO1xufVxudmFyIEggPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoTCkubWFwKCh0KSA9PiB0LnJldmVyc2UoKSkpLCBGID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKFcpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKSwgSyA9IGAke09iamVjdC52YWx1ZXMoVykubWFwKCh0KSA9PiBgXFxcXHV7JHt0LnRvU3RyaW5nKDE2KX19YCkuam9pbihcIlwiKX1gLCBPID0gbmV3IFJlZ0V4cChgWyR7S31dezQsfWAsIFwiZ3VcIik7XG5mdW5jdGlvbiBYKHQpIHtcbiAgbGV0IG4gPSB0Lm1hdGNoKE8pO1xuICBpZiAobikgcmV0dXJuIFkoblswXSwgITApWzBdO1xufVxuZnVuY3Rpb24gWSh0LCBuID0gITEpIHtcbiAgbGV0IG8gPSBBcnJheS5mcm9tKHQpO1xuICBpZiAoby5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgaWYgKG8ubGVuZ3RoICUgNCB8fCAhdC5zdGFydHNXaXRoKGopKSByZXR1cm4gZWUobywgbik7XG4gIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvZGVkIGRhdGEgaGFzIGludmFsaWQgbGVuZ3RoXCIpO1xuICBsZXQgZSA9IFtdO1xuICBmb3IgKGxldCByID0gby5sZW5ndGggKiAwLjI1OyByLS07ICkge1xuICAgIGxldCBzID0gby5zbGljZShyICogNCwgciAqIDQgKyA0KS5tYXAoKGMpID0+IEhbYy5jb2RlUG9pbnRBdCgwKV0pLmpvaW4oXCJcIik7XG4gICAgZS51bnNoaWZ0KFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocywgNCkpKTtcbiAgfVxuICBpZiAobikge1xuICAgIGUuc2hpZnQoKTtcbiAgICBsZXQgciA9IGUuaW5kZXhPZihWKTtcbiAgICByZXR1cm4gciA9PT0gLTEgJiYgKHIgPSBlLmxlbmd0aCksIFtKU09OLnBhcnNlKGUuc2xpY2UoMCwgcikuam9pbihcIlwiKSldO1xuICB9XG4gIHJldHVybiBlLmpvaW4oXCJcIikuc3BsaXQoVikuZmlsdGVyKEJvb2xlYW4pLm1hcCgocikgPT4gSlNPTi5wYXJzZShyKSk7XG59XG5mdW5jdGlvbiBlZSh0LCBuKSB7XG4gIHZhciBvO1xuICBsZXQgZSA9IFtdO1xuICBmb3IgKGxldCBpID0gdC5sZW5ndGggKiAwLjU7IGktLTsgKSB7XG4gICAgbGV0IHUgPSBgJHtGW3RbaSAqIDJdLmNvZGVQb2ludEF0KDApXX0ke0ZbdFtpICogMiArIDFdLmNvZGVQb2ludEF0KDApXX1gO1xuICAgIGUudW5zaGlmdChTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHUsIDE2KSkpO1xuICB9XG4gIGxldCByID0gW10sIHMgPSBbZS5qb2luKFwiXCIpXSwgYyA9IDEwO1xuICBmb3IgKDsgcy5sZW5ndGg7ICkge1xuICAgIGxldCBpID0gcy5zaGlmdCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoci5wdXNoKEpTT04ucGFyc2UoaSkpLCBuKSByZXR1cm4gcjtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpZiAoIWMtLSkgdGhyb3cgdTtcbiAgICAgIGxldCBhID0gKygobyA9IHUubWVzc2FnZS5tYXRjaCgvXFxzcG9zaXRpb25cXHMoXFxkKykkLykpID09IG51bGwgPyB2b2lkIDAgOiBvWzFdKTtcbiAgICAgIGlmICghYSkgdGhyb3cgdTtcbiAgICAgIHMudW5zaGlmdChpLnN1YnN0cmluZygwLCBhKSwgaS5zdWJzdHJpbmcoYSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHRlKHQpIHtcbiAgdmFyIG47XG4gIHJldHVybiB7IGNsZWFuZWQ6IHQucmVwbGFjZShPLCBcIlwiKSwgZW5jb2RlZDogKChuID0gdC5tYXRjaChPKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG5bMF0pIHx8IFwiXCIgfTtcbn1cbmZ1bmN0aW9uIHcodCwgbikge1xuICByZXR1cm4gRyh0LCBuKTtcbn1cbmZ1bmN0aW9uIGllKHQpIHtcbiAgcmV0dXJuIFUodCk7XG59XG5mdW5jdGlvbiBhZSh0KSB7XG4gIHJldHVybiBYKHQpO1xufVxuZnVuY3Rpb24gdWUodCkge1xuICByZXR1cm4gdGUodCk7XG59XG52YXIgeCwgaztcbmZ1bmN0aW9uIG5lKCkge1xuICBpZiAoaykgcmV0dXJuIHg7XG4gIGsgPSAxO1xuICB2YXIgdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICByZXR1cm4geCA9IGZ1bmN0aW9uKGUsIHIsIHMpIHtcbiAgICBpZiAobi5jYWxsKHIpICE9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIHZhciBjID0gZS5sZW5ndGg7XG4gICAgaWYgKGMgPT09ICtjKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyBpKyspXG4gICAgICAgIHIuY2FsbChzLCBlW2ldLCBpLCBlKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciB1IGluIGUpXG4gICAgICAgIHQuY2FsbChlLCB1KSAmJiByLmNhbGwocywgZVt1XSwgdSwgZSk7XG4gIH0sIHg7XG59XG52YXIgSSwgXztcbmZ1bmN0aW9uIHJlKCkge1xuICBpZiAoXykgcmV0dXJuIEk7XG4gIF8gPSAxO1xuICB2YXIgdCA9IG5lKCk7XG4gIEkgPSBuO1xuICBmdW5jdGlvbiBuKG8sIGUsIHIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICAgIHJldHVybiBuLnNldChvLCBlLCByKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgIHJldHVybiBuLmdldChvLCBlKTtcbiAgICB2YXIgcyA9IG4uYmluZChuLCBvKTtcbiAgICBmb3IgKHZhciBjIGluIG4pXG4gICAgICBuLmhhc093blByb3BlcnR5KGMpICYmIChzW2NdID0gbltjXS5iaW5kKHMsIG8pKTtcbiAgICByZXR1cm4gcztcbiAgfVxuICByZXR1cm4gbi5nZXQgPSBmdW5jdGlvbihlLCByKSB7XG4gICAgZm9yICh2YXIgcyA9IEFycmF5LmlzQXJyYXkocikgPyByIDogbi5wYXJzZShyKSwgYyA9IDA7IGMgPCBzLmxlbmd0aDsgKytjKSB7XG4gICAgICB2YXIgaSA9IHNbY107XG4gICAgICBpZiAoISh0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGkgaW4gZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVmZXJlbmNlIHRva2VuOiBcIiArIGkpO1xuICAgICAgZSA9IGVbaV07XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBuLnNldCA9IGZ1bmN0aW9uKGUsIHIsIHMpIHtcbiAgICB2YXIgYyA9IEFycmF5LmlzQXJyYXkocikgPyByIDogbi5wYXJzZShyKSwgaSA9IGNbMF07XG4gICAgaWYgKGMubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgRXJyb3IoXCJDYW4gbm90IHNldCB0aGUgcm9vdCBvYmplY3RcIik7XG4gICAgZm9yICh2YXIgdSA9IDA7IHUgPCBjLmxlbmd0aCAtIDE7ICsrdSkge1xuICAgICAgdmFyIGEgPSBjW3VdO1xuICAgICAgdHlwZW9mIGEgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYSAhPSBcIm51bWJlclwiICYmIChhID0gU3RyaW5nKGEpKSwgIShhID09PSBcIl9fcHJvdG9fX1wiIHx8IGEgPT09IFwiY29uc3RydWN0b3JcIiB8fCBhID09PSBcInByb3RvdHlwZVwiKSAmJiAoYSA9PT0gXCItXCIgJiYgQXJyYXkuaXNBcnJheShlKSAmJiAoYSA9IGUubGVuZ3RoKSwgaSA9IGNbdSArIDFdLCBhIGluIGUgfHwgKGkubWF0Y2goL14oXFxkK3wtKSQvKSA/IGVbYV0gPSBbXSA6IGVbYV0gPSB7fSksIGUgPSBlW2FdKTtcbiAgICB9XG4gICAgcmV0dXJuIGkgPT09IFwiLVwiICYmIEFycmF5LmlzQXJyYXkoZSkgJiYgKGkgPSBlLmxlbmd0aCksIGVbaV0gPSBzLCB0aGlzO1xuICB9LCBuLnJlbW92ZSA9IGZ1bmN0aW9uKG8sIGUpIHtcbiAgICB2YXIgciA9IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogbi5wYXJzZShlKSwgcyA9IHJbci5sZW5ndGggLSAxXTtcbiAgICBpZiAocyA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlciBmb3IgcmVtb3ZlOiBcIicgKyBlICsgJ1wiJyk7XG4gICAgdmFyIGMgPSBuLmdldChvLCByLnNsaWNlKDAsIC0xKSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHZhciBpID0gK3M7XG4gICAgICBpZiAocyA9PT0gXCJcIiAmJiBpc05hTihpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFycmF5IGluZGV4OiBcIicgKyBzICsgJ1wiJyk7XG4gICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYywgaSwgMSk7XG4gICAgfSBlbHNlXG4gICAgICBkZWxldGUgY1tzXTtcbiAgfSwgbi5kaWN0ID0gZnVuY3Rpb24oZSwgcikge1xuICAgIHZhciBzID0ge307XG4gICAgcmV0dXJuIG4ud2FsayhlLCBmdW5jdGlvbihjLCBpKSB7XG4gICAgICBzW2ldID0gYztcbiAgICB9LCByKSwgcztcbiAgfSwgbi53YWxrID0gZnVuY3Rpb24oZSwgciwgcykge1xuICAgIHZhciBjID0gW107XG4gICAgcyA9IHMgfHwgZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIHUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaSk7XG4gICAgICByZXR1cm4gdSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiB8fCB1ID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSwgZnVuY3Rpb24gaSh1KSB7XG4gICAgICB0KHUsIGZ1bmN0aW9uKGEsIGwpIHtcbiAgICAgICAgYy5wdXNoKFN0cmluZyhsKSksIHMoYSkgPyBpKGEpIDogcihhLCBuLmNvbXBpbGUoYykpLCBjLnBvcCgpO1xuICAgICAgfSk7XG4gICAgfShlKTtcbiAgfSwgbi5oYXMgPSBmdW5jdGlvbihlLCByKSB7XG4gICAgdHJ5IHtcbiAgICAgIG4uZ2V0KGUsIHIpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9LCBuLmVzY2FwZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZS50b1N0cmluZygpLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbiAgfSwgbi51bmVzY2FwZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZS5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xuICB9LCBuLnBhcnNlID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlID09PSBcIlwiKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gXCIvXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEpTT04gcG9pbnRlcjogXCIgKyBlKTtcbiAgICByZXR1cm4gZS5zdWJzdHJpbmcoMSkuc3BsaXQoL1xcLy8pLm1hcChuLnVuZXNjYXBlKTtcbiAgfSwgbi5jb21waWxlID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLmxlbmd0aCA9PT0gMCA/IFwiXCIgOiBcIi9cIiArIGUubWFwKG4uZXNjYXBlKS5qb2luKFwiL1wiKTtcbiAgfSwgSTtcbn1cbnZhciBwID0gcmUoKTtcbmNvbnN0IG9lID0gKHtcbiAgcG9pbnRlcjogdCxcbiAgbWFwcGluZ3M6IG4sXG4gIGRhdGE6IG8sXG4gIGhpZGRlblN0cmluZ3M6IGVcbn0pID0+IHtcbiAgY29uc3QgciA9IG5bdF07XG4gIGlmIChyKSB7XG4gICAgZGVsZXRlIG5bdF07XG4gICAgY29uc3QgcyA9IGIobywgdCk7XG4gICAgZm9yIChjb25zdCBjIG9mIHMpIHtcbiAgICAgIG5bY10gPSByO1xuICAgICAgY29uc3QgaSA9IHAuZ2V0KG8sIGMpLCB1ID0gdyhpLCBlKTtcbiAgICAgIHAuc2V0KG8sIGMsIHUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzID0gYihvLCB0KTtcbiAgICBmb3IgKGNvbnN0IGMgb2Ygcykge1xuICAgICAgY29uc3QgaSA9IHAuZ2V0KG8sIGMpLCB1ID0gdyhpLCBlKTtcbiAgICAgIHAuc2V0KG8sIGMsIHUpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNlKHQpIHtcbiAgcmV0dXJuIFwiY29udGVudFwiIGluIHQgJiYgISF0LmNvbnRlbnQ7XG59XG5jb25zdCBiID0gKHQsIG4gPSBcIlwiKSA9PiB7XG4gIGNvbnN0IG8gPSBbXSwgZSA9IHAuZ2V0KHQsIG4pO1xuICBpZiAoc2UoZSkpXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmNvbnRlbnQubGVuZ3RoOyByKyspXG4gICAgICBlLmNvbnRlbnRbcl0ubm9kZVR5cGUgPT09IFwidGV4dFwiID8gby5wdXNoKGAke259L2NvbnRlbnQvJHtyfS92YWx1ZWApIDogby5wdXNoKC4uLmIodCwgYCR7bn0vY29udGVudC8ke3J9YCkpO1xuICByZXR1cm4gbztcbn0sIEMgPSAoe1xuICBlbnRpdHlJZDogdCxcbiAgZW50aXR5VHlwZTogbixcbiAgc3BhY2U6IG8sXG4gIGVudmlyb25tZW50OiBlLFxuICBmaWVsZDogcixcbiAgbG9jYWxlOiBzLFxuICBlZGl0b3JJbnRlcmZhY2U6IGMsXG4gIGZpZWxkVHlwZTogaSxcbiAgdGFyZ2V0T3JpZ2luOiB1LFxuICBwbGF0Zm9ybTogYVxufSkgPT4ge1xuICBjb25zdCBkID0ge1xuICAgIG9yaWdpbjogXCJjb250ZW50ZnVsLmNvbVwiLFxuICAgIGhyZWY6IGAke2Ake3UgfHwgXCJodHRwczovL2FwcC5jb250ZW50ZnVsLmNvbVwifS9zcGFjZXMvJHtvfS9lbnZpcm9ubWVudHMvJHtlfWB9LyR7biA9PT0gXCJFbnRyeVwiID8gXCJlbnRyaWVzXCIgOiBcImFzc2V0c1wifS8ke3R9Lz9mb2N1c2VkRmllbGQ9JHtyfSZmb2N1c2VkTG9jYWxlPSR7c30mc291cmNlPXZlcmNlbC1jb250ZW50LWxpbmtgLFxuICAgIGNvbnRlbnRmdWw6IHtcbiAgICAgIGVkaXRvckludGVyZmFjZTogYyxcbiAgICAgIGZpZWxkVHlwZTogaVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGEgPT09IFwidmVyY2VsXCIgJiYgZGVsZXRlIGQuY29udGVudGZ1bCwgZDtcbn0sIEIgPSAodCkgPT4gW1wiYnVpbHRpblwiLCBcInNpZGViYXItYnVpbHRpblwiLCBcImVkaXRvci1idWlsdGluXCJdLmluY2x1ZGVzKHQpLCBEID0gKHQpID0+IGNlLmluY2x1ZGVzKHQpO1xuZnVuY3Rpb24gUSh0KSB7XG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlZENsb25lID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHQpO1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQpKTtcbiAgfSBjYXRjaCAobikge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2xvbmUgZGF0YTpcIiwgdCwgbiksIHQ7XG4gIH1cbn1cbmNvbnN0IGNlID0gW1xuICBcInNpbmdsZUxpbmVcIixcbiAgXCJ0YWdFZGl0b3JcIixcbiAgXCJsaXN0SW5wdXRcIixcbiAgXCJjaGVja2JveFwiLFxuICBcInJpY2hUZXh0RWRpdG9yXCIsXG4gIFwibXVsdGlwbGVMaW5lXCJcbl07XG5mdW5jdGlvbiBQKHQsIG4sIG8sIGUsIHIsIHMsIGMpIHtcbiAgY29uc3QgaSA9IGMgPyBuW2NdIDogbjtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcIlN5bWJvbFwiOiB7XG4gICAgICBjb25zdCB1ID0gdyhpLCBvKTtcbiAgICAgIHAuc2V0KGUsIHIsIHUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJUZXh0XCI6IHtcbiAgICAgIGNvbnN0IHUgPSB3KGksIG8pO1xuICAgICAgcC5zZXQoZSwgciwgdSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIlJpY2hUZXh0XCI6IHtcbiAgICAgIG9lKHtcbiAgICAgICAgcG9pbnRlcjogXCJcIixcbiAgICAgICAgbWFwcGluZ3M6IHMsXG4gICAgICAgIGRhdGE6IGksXG4gICAgICAgIGhpZGRlblN0cmluZ3M6IG9cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJBcnJheVwiOiB7XG4gICAgICBjb25zdCB1ID0gaS5tYXAoKGEpID0+IHR5cGVvZiBhID09IFwic3RyaW5nXCIgPyB3KGEsIG8pIDogYSk7XG4gICAgICBwLnNldChlLCByLCB1KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuY29uc3QgZmUgPSAodCwgbiwgbykgPT4ge1xuICBpZiAoIXQgfHwgIXQuZXh0ZW5zaW9ucyB8fCAhdC5leHRlbnNpb25zLmNvbnRlbnRTb3VyY2VNYXBzKVxuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgXCJHcmFwaFFMIHJlc3BvbnNlIGRvZXMgbm90IGNvbnRhaW4gQ29udGVudCBTb3VyY2UgTWFwcyBpbmZvcm1hdGlvbi5cIixcbiAgICAgIHRcbiAgICApLCB0O1xuICBjb25zdCBlID0gUSh0KSwge1xuICAgIHNwYWNlczogcixcbiAgICBlbnZpcm9ubWVudHM6IHMsXG4gICAgZWRpdG9ySW50ZXJmYWNlczogYyxcbiAgICBmaWVsZHM6IGksXG4gICAgbG9jYWxlczogdSxcbiAgICBlbnRyaWVzOiBhLFxuICAgIGFzc2V0czogbCxcbiAgICBtYXBwaW5nczogbSxcbiAgICBmaWVsZFR5cGVzOiB2XG4gIH0gPSBlLmV4dGVuc2lvbnMuY29udGVudFNvdXJjZU1hcHMsIHkgPSBlO1xuICBmb3IgKGNvbnN0IGQgaW4gbSkge1xuICAgIGNvbnN0IHsgc291cmNlOiBmIH0gPSBtW2RdLCBoID0gXCJlbnRyeVwiIGluIGYgPyBhW2YuZW50cnldIDogbFtmLmFzc2V0XSwgTSA9IFwiZW50cnlcIiBpbiBmID8gXCJFbnRyeVwiIDogXCJBc3NldFwiO1xuICAgIGlmICghaClcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IGcgPSByW2guc3BhY2VdLCBBID0gc1toLmVudmlyb25tZW50XSwgRSA9IGguaWQsIFMgPSBpW2YuZmllbGRdLCBUID0gdVtmLmxvY2FsZV0sIE4gPSBjW2YuZWRpdG9ySW50ZXJmYWNlXSwgSiA9IHZbZi5maWVsZFR5cGVdO1xuICAgIGlmICghKEIoTi53aWRnZXROYW1lc3BhY2UpICYmICFEKE4ud2lkZ2V0SWQpKSAmJiBwLmhhcyh5LCBkKSkge1xuICAgICAgY29uc3QgUiA9IHAuZ2V0KHksIGQpO1xuICAgICAgaWYgKFIgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeiA9IEMoe1xuICAgICAgICAgIGVudGl0eUlkOiBFLFxuICAgICAgICAgIGVudGl0eVR5cGU6IE0sXG4gICAgICAgICAgc3BhY2U6IGcsXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IEEsXG4gICAgICAgICAgZmllbGQ6IFMsXG4gICAgICAgICAgbG9jYWxlOiBULFxuICAgICAgICAgIGVkaXRvckludGVyZmFjZTogTixcbiAgICAgICAgICBmaWVsZFR5cGU6IEosXG4gICAgICAgICAgdGFyZ2V0T3JpZ2luOiBuLFxuICAgICAgICAgIHBsYXRmb3JtOiBvXG4gICAgICAgIH0pO1xuICAgICAgICBQKEosIFIsIHosIHksIGQsIG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZTtcbn0sICQgPSAodCwgbiwgbywgZSwgcikgPT4ge1xuICBpZiAoIXQuZmllbGRzKVxuICAgIHJldHVybjtcbiAgY29uc3QgeyBjb250ZW50U291cmNlTWFwczogcyB9ID0gdC5zeXM7XG4gIGlmICghcylcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgbWFwcGluZ3M6IGMgfSA9IHM7XG4gIGZvciAoY29uc3QgaSBpbiBjKSB7XG4gICAgY29uc3QgeyBzb3VyY2U6IHUgfSA9IGNbaV0sIGEgPSB0LnN5cy5zcGFjZS5zeXMuaWQsIGwgPSB0LnN5cy5lbnZpcm9ubWVudC5zeXMuaWQsIG0gPSB0LnN5cy5pZCwgdiA9IHQuc3lzLnR5cGUsIHkgPSBuW3UuZmllbGRUeXBlXSwgZCA9IG9bdS5lZGl0b3JJbnRlcmZhY2VdO1xuICAgIGlmIChCKGQud2lkZ2V0TmFtZXNwYWNlKSAmJiAhRChkLndpZGdldElkKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGYgPSBpLnN0YXJ0c1dpdGgoXCIvXCIpID8gaSA6IGAvJHtpfWA7XG4gICAgaWYgKHAuaGFzKHQsIGYpKSB7XG4gICAgICBjb25zdCBoID0gcC5nZXQodCwgZik7XG4gICAgICBpZiAoaCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZyA9IGYuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgaWYgKCFnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGaWVsZCBuYW1lIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSB0aGUgcG9pbnRlclwiLCBmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgQSA9IHQuc3lzLmxvY2FsZTtcbiAgICAgIGlmIChBKSB7XG4gICAgICAgIGNvbnN0IEUgPSBDKHtcbiAgICAgICAgICBlbnRpdHlJZDogbSxcbiAgICAgICAgICBlbnRpdHlUeXBlOiB2LFxuICAgICAgICAgIHNwYWNlOiBhLFxuICAgICAgICAgIGVudmlyb25tZW50OiBsLFxuICAgICAgICAgIGZpZWxkOiBnLFxuICAgICAgICAgIGxvY2FsZTogQSxcbiAgICAgICAgICBlZGl0b3JJbnRlcmZhY2U6IGQsXG4gICAgICAgICAgZmllbGRUeXBlOiB5LFxuICAgICAgICAgIHRhcmdldE9yaWdpbjogZSxcbiAgICAgICAgICBwbGF0Zm9ybTogclxuICAgICAgICB9KTtcbiAgICAgICAgUCh5LCBoLCBFLCB0LCBmLCBjKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBPYmplY3Qua2V5cyhoKS5mb3JFYWNoKChTKSA9PiB7XG4gICAgICAgICAgY29uc3QgVCA9IEMoe1xuICAgICAgICAgICAgZW50aXR5SWQ6IG0sXG4gICAgICAgICAgICBlbnRpdHlUeXBlOiB2LFxuICAgICAgICAgICAgc3BhY2U6IGEsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogbCxcbiAgICAgICAgICAgIGZpZWxkOiBnLFxuICAgICAgICAgICAgbG9jYWxlOiBTLFxuICAgICAgICAgICAgZWRpdG9ySW50ZXJmYWNlOiBkLFxuICAgICAgICAgICAgZmllbGRUeXBlOiB5LFxuICAgICAgICAgICAgdGFyZ2V0T3JpZ2luOiBlLFxuICAgICAgICAgICAgcGxhdGZvcm06IHJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBQKFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBULFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIGAke2Z9LyR7U31gLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIFNcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbn0sIGxlID0gKHQsIG4sIG8pID0+IHtcbiAgdmFyIHI7XG4gIGNvbnN0IGUgPSBRKFxuICAgIHRcbiAgKTtcbiAgaWYgKGUuc3lzICYmIFwiaXRlbXNcIiBpbiBlKSB7XG4gICAgY29uc3QgcyA9IGU7XG4gICAgaWYgKCEoKHIgPSBzLnN5cykgIT0gbnVsbCAmJiByLmNvbnRlbnRTb3VyY2VNYXBzTG9va3VwKSlcbiAgICAgIHJldHVybiBzO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRTb3VyY2VNYXBzTG9va3VwOiB7IGZpZWxkVHlwZXM6IGMsIGVkaXRvckludGVyZmFjZXM6IGkgfVxuICAgIH0gPSBzLnN5cywgeyBpdGVtczogdSwgaW5jbHVkZXM6IGEgfSA9IHM7XG4gICAgdS5mb3JFYWNoKFxuICAgICAgKGwpID0+ICQobCwgYywgaSwgbiwgbylcbiAgICApLCBhICYmIGEuRW50cnkgJiYgYS5FbnRyeS5mb3JFYWNoKFxuICAgICAgKGwpID0+ICQobCwgYywgaSwgbiwgbylcbiAgICApLCBhICYmIGEuQXNzZXQgJiYgYS5Bc3NldC5mb3JFYWNoKFxuICAgICAgKGwpID0+ICQobCwgYywgaSwgbiwgbylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHMgPSBlO1xuICAgIGlmICghcy5zeXMuY29udGVudFNvdXJjZU1hcHNMb29rdXApXG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkNvbnRlbnQgc291cmNlIG1hcHMgbG9va3VwIGRhdGEgaXMgbWlzc2luZ1wiKSwgcztcbiAgICAkKFxuICAgICAgcyxcbiAgICAgIHMuc3lzLmNvbnRlbnRTb3VyY2VNYXBzTG9va3VwLmZpZWxkVHlwZXMsXG4gICAgICBzLnN5cy5jb250ZW50U291cmNlTWFwc0xvb2t1cC5lZGl0b3JJbnRlcmZhY2VzLFxuICAgICAgbixcbiAgICAgIG9cbiAgICApO1xuICB9XG4gIHJldHVybiBlO1xufTtcbmV4cG9ydCB7XG4gIGNlIGFzIFNVUFBPUlRFRF9XSURHRVRTLFxuICBRIGFzIGNsb25lLFxuICB3IGFzIGNvbWJpbmUsXG4gIEMgYXMgY3JlYXRlU291cmNlTWFwTWV0YWRhdGEsXG4gIGFlIGFzIGRlY29kZSxcbiAgaWUgYXMgZW5jb2RlLFxuICBsZSBhcyBlbmNvZGVDUEFSZXNwb25zZSxcbiAgUCBhcyBlbmNvZGVGaWVsZCxcbiAgZmUgYXMgZW5jb2RlR3JhcGhRTFJlc3BvbnNlLFxuICBvZSBhcyBlbmNvZGVSaWNoVGV4dFZhbHVlLFxuICBCIGFzIGlzQnVpbHRpbk5hbWVzcGFjZSxcbiAgRCBhcyBpc1N1cHBvcnRlZFdpZGdldCxcbiAgdWUgYXMgc3BsaXRFbmNvZGluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@contentful/content-source-maps/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@contentful/rich-text-react-renderer/dist/rich-text-react-renderer.es5.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@contentful/rich-text-react-renderer/dist/rich-text-react-renderer.es5.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar React = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\");\nvar richTextTypes = __webpack_require__(/*! @contentful/rich-text-types */ \"(rsc)/./node_modules/@contentful/rich-text-types/dist/index.js\");\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nfunction appendKeyToValidElement(element, key) {\n    if (React.isValidElement(element) && element.key === null) {\n        return React.cloneElement(element, { key: key });\n    }\n    return element;\n}\n\nfunction nodeListToReactComponents(nodes, options) {\n    return nodes.map(function (node, index) {\n        return appendKeyToValidElement(nodeToReactComponent(node, options), index);\n    });\n}\nfunction nodeToReactComponent(node, options) {\n    var renderNode = options.renderNode, renderMark = options.renderMark, renderText = options.renderText, preserveWhitespace = options.preserveWhitespace;\n    if (richTextTypes.helpers.isText(node)) {\n        var nodeValue = renderText ? renderText(node.value) : node.value;\n        // Preserving whitespace is only supported with the default transformations.\n        if (preserveWhitespace && !renderText) {\n            // Preserve multiple spaces.\n            nodeValue = nodeValue.replace(/ {2,}/g, function (match) { return '\\u00A0'.repeat(match.length); });\n            // Preserve line breaks.\n            var lines_1 = nodeValue.split('\\n');\n            var jsxLines_1 = [];\n            lines_1.forEach(function (line, index) {\n                jsxLines_1.push(line);\n                if (index !== lines_1.length - 1) {\n                    jsxLines_1.push(React.createElement(\"br\", null));\n                }\n            });\n            nodeValue = jsxLines_1;\n        }\n        return node.marks.reduce(function (value, mark) {\n            if (!renderMark[mark.type]) {\n                return value;\n            }\n            return renderMark[mark.type](value);\n        }, nodeValue);\n    }\n    else {\n        var children = nodeListToReactComponents(node.content, options);\n        if (!node.nodeType || !renderNode[node.nodeType]) {\n            return React.createElement(React.Fragment, null, children);\n        }\n        return renderNode[node.nodeType](node, children);\n    }\n}\n\nvar _a, _b;\nvar defaultNodeRenderers = (_a = {},\n    _a[richTextTypes.BLOCKS.DOCUMENT] = function (node, children) { return children; },\n    _a[richTextTypes.BLOCKS.PARAGRAPH] = function (node, children) { return React.createElement(\"p\", null, children); },\n    _a[richTextTypes.BLOCKS.HEADING_1] = function (node, children) { return React.createElement(\"h1\", null, children); },\n    _a[richTextTypes.BLOCKS.HEADING_2] = function (node, children) { return React.createElement(\"h2\", null, children); },\n    _a[richTextTypes.BLOCKS.HEADING_3] = function (node, children) { return React.createElement(\"h3\", null, children); },\n    _a[richTextTypes.BLOCKS.HEADING_4] = function (node, children) { return React.createElement(\"h4\", null, children); },\n    _a[richTextTypes.BLOCKS.HEADING_5] = function (node, children) { return React.createElement(\"h5\", null, children); },\n    _a[richTextTypes.BLOCKS.HEADING_6] = function (node, children) { return React.createElement(\"h6\", null, children); },\n    _a[richTextTypes.BLOCKS.EMBEDDED_ENTRY] = function (node, children) { return React.createElement(\"div\", null, children); },\n    _a[richTextTypes.BLOCKS.EMBEDDED_RESOURCE] = function (node, children) { return React.createElement(\"div\", null, children); },\n    _a[richTextTypes.BLOCKS.UL_LIST] = function (node, children) { return React.createElement(\"ul\", null, children); },\n    _a[richTextTypes.BLOCKS.OL_LIST] = function (node, children) { return React.createElement(\"ol\", null, children); },\n    _a[richTextTypes.BLOCKS.LIST_ITEM] = function (node, children) { return React.createElement(\"li\", null, children); },\n    _a[richTextTypes.BLOCKS.QUOTE] = function (node, children) { return React.createElement(\"blockquote\", null, children); },\n    _a[richTextTypes.BLOCKS.HR] = function () { return React.createElement(\"hr\", null); },\n    _a[richTextTypes.BLOCKS.TABLE] = function (node, children) { return (React.createElement(\"table\", null,\n        React.createElement(\"tbody\", null, children))); },\n    _a[richTextTypes.BLOCKS.TABLE_ROW] = function (node, children) { return React.createElement(\"tr\", null, children); },\n    _a[richTextTypes.BLOCKS.TABLE_HEADER_CELL] = function (node, children) { return React.createElement(\"th\", null, children); },\n    _a[richTextTypes.BLOCKS.TABLE_CELL] = function (node, children) { return React.createElement(\"td\", null, children); },\n    _a[richTextTypes.INLINES.ASSET_HYPERLINK] = function (node) { return defaultInline(richTextTypes.INLINES.ASSET_HYPERLINK, node); },\n    _a[richTextTypes.INLINES.ENTRY_HYPERLINK] = function (node) { return defaultInline(richTextTypes.INLINES.ENTRY_HYPERLINK, node); },\n    _a[richTextTypes.INLINES.RESOURCE_HYPERLINK] = function (node) {\n        return defaultInlineResource(richTextTypes.INLINES.RESOURCE_HYPERLINK, node);\n    },\n    _a[richTextTypes.INLINES.EMBEDDED_ENTRY] = function (node) { return defaultInline(richTextTypes.INLINES.EMBEDDED_ENTRY, node); },\n    _a[richTextTypes.INLINES.EMBEDDED_RESOURCE] = function (node, _children) {\n        return defaultInlineResource(richTextTypes.INLINES.EMBEDDED_RESOURCE, node);\n    },\n    _a[richTextTypes.INLINES.HYPERLINK] = function (node, children) { return React.createElement(\"a\", { href: node.data.uri }, children); },\n    _a);\nvar defaultMarkRenderers = (_b = {},\n    _b[richTextTypes.MARKS.BOLD] = function (text) { return React.createElement(\"b\", null, text); },\n    _b[richTextTypes.MARKS.ITALIC] = function (text) { return React.createElement(\"i\", null, text); },\n    _b[richTextTypes.MARKS.UNDERLINE] = function (text) { return React.createElement(\"u\", null, text); },\n    _b[richTextTypes.MARKS.CODE] = function (text) { return React.createElement(\"code\", null, text); },\n    _b[richTextTypes.MARKS.SUPERSCRIPT] = function (text) { return React.createElement(\"sup\", null, text); },\n    _b[richTextTypes.MARKS.SUBSCRIPT] = function (text) { return React.createElement(\"sub\", null, text); },\n    _b[richTextTypes.MARKS.STRIKETHROUGH] = function (text) { return React.createElement(\"s\", null, text); },\n    _b);\nfunction defaultInline(type, node) {\n    return (React.createElement(\"span\", { key: node.data.target.sys.id },\n        \"type: \",\n        node.nodeType,\n        \" id: \",\n        node.data.target.sys.id));\n}\nfunction defaultInlineResource(type, node) {\n    return (React.createElement(\"span\", { key: node.data.target.sys.urn },\n        \"type: \",\n        node.nodeType,\n        \" urn: \",\n        node.data.target.sys.urn));\n}\n/**\n * Serialize a Contentful Rich Text `document` to React tree\n */\nfunction documentToReactComponents(richTextDocument, options) {\n    if (options === void 0) { options = {}; }\n    if (!richTextDocument) {\n        return null;\n    }\n    // Strip empty trailing paragraph if enabled\n    var processedDocument = richTextDocument;\n    if (options.stripEmptyTrailingParagraph) {\n        processedDocument = richTextTypes.helpers.stripEmptyTrailingParagraphFromDocument(richTextDocument);\n    }\n    return nodeToReactComponent(processedDocument, {\n        renderNode: __assign(__assign({}, defaultNodeRenderers), options.renderNode),\n        renderMark: __assign(__assign({}, defaultMarkRenderers), options.renderMark),\n        renderText: options.renderText,\n        preserveWhitespace: options.preserveWhitespace,\n    });\n}\n\nexports.documentToReactComponents = documentToReactComponents;\n//# sourceMappingURL=rich-text-react-renderer.es5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvbnRlbnRmdWwvcmljaC10ZXh0LXJlYWN0LXJlbmRlcmVyL2Rpc3QvcmljaC10ZXh0LXJlYWN0LXJlbmRlcmVyLmVzNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsaUdBQU87QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsbUdBQTZCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEdBQUcsdUJBQXVCLHVDQUF1QztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQyxvRUFBb0Usa0JBQWtCO0FBQ3RGLHFFQUFxRSxrREFBa0Q7QUFDdkgscUVBQXFFLG1EQUFtRDtBQUN4SCxxRUFBcUUsbURBQW1EO0FBQ3hILHFFQUFxRSxtREFBbUQ7QUFDeEgscUVBQXFFLG1EQUFtRDtBQUN4SCxxRUFBcUUsbURBQW1EO0FBQ3hILHFFQUFxRSxtREFBbUQ7QUFDeEgsMEVBQTBFLG9EQUFvRDtBQUM5SCw2RUFBNkUsb0RBQW9EO0FBQ2pJLG1FQUFtRSxtREFBbUQ7QUFDdEgsbUVBQW1FLG1EQUFtRDtBQUN0SCxxRUFBcUUsbURBQW1EO0FBQ3hILGlFQUFpRSwyREFBMkQ7QUFDNUgsZ0RBQWdELHlDQUF5QztBQUN6RixpRUFBaUU7QUFDakUseURBQXlEO0FBQ3pELHFFQUFxRSxtREFBbUQ7QUFDeEgsNkVBQTZFLG1EQUFtRDtBQUNoSSxzRUFBc0UsbURBQW1EO0FBQ3pILGtFQUFrRSxvRUFBb0U7QUFDdEksa0VBQWtFLG9FQUFvRTtBQUN0STtBQUNBO0FBQ0EsS0FBSztBQUNMLGlFQUFpRSxtRUFBbUU7QUFDcEk7QUFDQTtBQUNBLEtBQUs7QUFDTCxzRUFBc0Usa0NBQWtDLHFCQUFxQixjQUFjO0FBQzNJO0FBQ0EsbUNBQW1DO0FBQ25DLHFEQUFxRCw4Q0FBOEM7QUFDbkcsdURBQXVELDhDQUE4QztBQUNyRywwREFBMEQsOENBQThDO0FBQ3hHLHFEQUFxRCxpREFBaUQ7QUFDdEcsNERBQTRELGdEQUFnRDtBQUM1RywwREFBMEQsZ0RBQWdEO0FBQzFHLDhEQUE4RCw4Q0FBOEM7QUFDNUc7QUFDQTtBQUNBLDBDQUEwQyw4QkFBOEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtCQUErQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsiL1VzZXJzL3VzZXIvRGVza3RvcC9wb3J0c21vdXRoL25vZGVfbW9kdWxlcy9AY29udGVudGZ1bC9yaWNoLXRleHQtcmVhY3QtcmVuZGVyZXIvZGlzdC9yaWNoLXRleHQtcmVhY3QtcmVuZGVyZXIuZXM1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciByaWNoVGV4dFR5cGVzID0gcmVxdWlyZSgnQGNvbnRlbnRmdWwvcmljaC10ZXh0LXR5cGVzJyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbmZ1bmN0aW9uIGFwcGVuZEtleVRvVmFsaWRFbGVtZW50KGVsZW1lbnQsIGtleSkge1xuICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50LmtleSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHsga2V5OiBrZXkgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBub2RlTGlzdFRvUmVhY3RDb21wb25lbnRzKG5vZGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFwcGVuZEtleVRvVmFsaWRFbGVtZW50KG5vZGVUb1JlYWN0Q29tcG9uZW50KG5vZGUsIG9wdGlvbnMpLCBpbmRleCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub2RlVG9SZWFjdENvbXBvbmVudChub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlck5vZGUgPSBvcHRpb25zLnJlbmRlck5vZGUsIHJlbmRlck1hcmsgPSBvcHRpb25zLnJlbmRlck1hcmssIHJlbmRlclRleHQgPSBvcHRpb25zLnJlbmRlclRleHQsIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlO1xuICAgIGlmIChyaWNoVGV4dFR5cGVzLmhlbHBlcnMuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHZhciBub2RlVmFsdWUgPSByZW5kZXJUZXh0ID8gcmVuZGVyVGV4dChub2RlLnZhbHVlKSA6IG5vZGUudmFsdWU7XG4gICAgICAgIC8vIFByZXNlcnZpbmcgd2hpdGVzcGFjZSBpcyBvbmx5IHN1cHBvcnRlZCB3aXRoIHRoZSBkZWZhdWx0IHRyYW5zZm9ybWF0aW9ucy5cbiAgICAgICAgaWYgKHByZXNlcnZlV2hpdGVzcGFjZSAmJiAhcmVuZGVyVGV4dCkge1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgbXVsdGlwbGUgc3BhY2VzLlxuICAgICAgICAgICAgbm9kZVZhbHVlID0gbm9kZVZhbHVlLnJlcGxhY2UoLyB7Mix9L2csIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gJ1xcdTAwQTAnLnJlcGVhdChtYXRjaC5sZW5ndGgpOyB9KTtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGxpbmUgYnJlYWtzLlxuICAgICAgICAgICAgdmFyIGxpbmVzXzEgPSBub2RlVmFsdWUuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIGpzeExpbmVzXzEgPSBbXTtcbiAgICAgICAgICAgIGxpbmVzXzEuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBqc3hMaW5lc18xLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBsaW5lc18xLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAganN4TGluZXNfMS5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlVmFsdWUgPSBqc3hMaW5lc18xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLm1hcmtzLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIG1hcmspIHtcbiAgICAgICAgICAgIGlmICghcmVuZGVyTWFya1ttYXJrLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlck1hcmtbbWFyay50eXBlXSh2YWx1ZSk7XG4gICAgICAgIH0sIG5vZGVWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlTGlzdFRvUmVhY3RDb21wb25lbnRzKG5vZGUuY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbm9kZS5ub2RlVHlwZSB8fCAhcmVuZGVyTm9kZVtub2RlLm5vZGVUeXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyTm9kZVtub2RlLm5vZGVUeXBlXShub2RlLCBjaGlsZHJlbik7XG4gICAgfVxufVxuXG52YXIgX2EsIF9iO1xudmFyIGRlZmF1bHROb2RlUmVuZGVyZXJzID0gKF9hID0ge30sXG4gICAgX2FbcmljaFRleHRUeXBlcy5CTE9DS1MuRE9DVU1FTlRdID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBjaGlsZHJlbjsgfSxcbiAgICBfYVtyaWNoVGV4dFR5cGVzLkJMT0NLUy5QQVJBR1JBUEhdID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBjaGlsZHJlbik7IH0sXG4gICAgX2FbcmljaFRleHRUeXBlcy5CTE9DS1MuSEVBRElOR18xXSA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZHJlbikgeyByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIG51bGwsIGNoaWxkcmVuKTsgfSxcbiAgICBfYVtyaWNoVGV4dFR5cGVzLkJMT0NLUy5IRUFESU5HXzJdID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgY2hpbGRyZW4pOyB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuQkxPQ0tTLkhFQURJTkdfM10gPSBmdW5jdGlvbiAobm9kZSwgY2hpbGRyZW4pIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCBudWxsLCBjaGlsZHJlbik7IH0sXG4gICAgX2FbcmljaFRleHRUeXBlcy5CTE9DS1MuSEVBRElOR180XSA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZHJlbikgeyByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIG51bGwsIGNoaWxkcmVuKTsgfSxcbiAgICBfYVtyaWNoVGV4dFR5cGVzLkJMT0NLUy5IRUFESU5HXzVdID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgY2hpbGRyZW4pOyB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuQkxPQ0tTLkhFQURJTkdfNl0gPSBmdW5jdGlvbiAobm9kZSwgY2hpbGRyZW4pIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNlwiLCBudWxsLCBjaGlsZHJlbik7IH0sXG4gICAgX2FbcmljaFRleHRUeXBlcy5CTE9DS1MuRU1CRURERURfRU5UUlldID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIGNoaWxkcmVuKTsgfSxcbiAgICBfYVtyaWNoVGV4dFR5cGVzLkJMT0NLUy5FTUJFRERFRF9SRVNPVVJDRV0gPSBmdW5jdGlvbiAobm9kZSwgY2hpbGRyZW4pIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgY2hpbGRyZW4pOyB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuQkxPQ0tTLlVMX0xJU1RdID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgbnVsbCwgY2hpbGRyZW4pOyB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuQkxPQ0tTLk9MX0xJU1RdID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwib2xcIiwgbnVsbCwgY2hpbGRyZW4pOyB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuQkxPQ0tTLkxJU1RfSVRFTV0gPSBmdW5jdGlvbiAobm9kZSwgY2hpbGRyZW4pIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBudWxsLCBjaGlsZHJlbik7IH0sXG4gICAgX2FbcmljaFRleHRUeXBlcy5CTE9DS1MuUVVPVEVdID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYmxvY2txdW90ZVwiLCBudWxsLCBjaGlsZHJlbik7IH0sXG4gICAgX2FbcmljaFRleHRUeXBlcy5CTE9DS1MuSFJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImhyXCIsIG51bGwpOyB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuQkxPQ0tTLlRBQkxFXSA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZHJlbikgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCwgY2hpbGRyZW4pKSk7IH0sXG4gICAgX2FbcmljaFRleHRUeXBlcy5CTE9DS1MuVEFCTEVfUk9XXSA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZHJlbikgeyByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsIGNoaWxkcmVuKTsgfSxcbiAgICBfYVtyaWNoVGV4dFR5cGVzLkJMT0NLUy5UQUJMRV9IRUFERVJfQ0VMTF0gPSBmdW5jdGlvbiAobm9kZSwgY2hpbGRyZW4pIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCBudWxsLCBjaGlsZHJlbik7IH0sXG4gICAgX2FbcmljaFRleHRUeXBlcy5CTE9DS1MuVEFCTEVfQ0VMTF0gPSBmdW5jdGlvbiAobm9kZSwgY2hpbGRyZW4pIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCBjaGlsZHJlbik7IH0sXG4gICAgX2FbcmljaFRleHRUeXBlcy5JTkxJTkVTLkFTU0VUX0hZUEVSTElOS10gPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZGVmYXVsdElubGluZShyaWNoVGV4dFR5cGVzLklOTElORVMuQVNTRVRfSFlQRVJMSU5LLCBub2RlKTsgfSxcbiAgICBfYVtyaWNoVGV4dFR5cGVzLklOTElORVMuRU5UUllfSFlQRVJMSU5LXSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBkZWZhdWx0SW5saW5lKHJpY2hUZXh0VHlwZXMuSU5MSU5FUy5FTlRSWV9IWVBFUkxJTkssIG5vZGUpOyB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuSU5MSU5FUy5SRVNPVVJDRV9IWVBFUkxJTktdID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRJbmxpbmVSZXNvdXJjZShyaWNoVGV4dFR5cGVzLklOTElORVMuUkVTT1VSQ0VfSFlQRVJMSU5LLCBub2RlKTtcbiAgICB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuSU5MSU5FUy5FTUJFRERFRF9FTlRSWV0gPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZGVmYXVsdElubGluZShyaWNoVGV4dFR5cGVzLklOTElORVMuRU1CRURERURfRU5UUlksIG5vZGUpOyB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuSU5MSU5FUy5FTUJFRERFRF9SRVNPVVJDRV0gPSBmdW5jdGlvbiAobm9kZSwgX2NoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SW5saW5lUmVzb3VyY2UocmljaFRleHRUeXBlcy5JTkxJTkVTLkVNQkVEREVEX1JFU09VUkNFLCBub2RlKTtcbiAgICB9LFxuICAgIF9hW3JpY2hUZXh0VHlwZXMuSU5MSU5FUy5IWVBFUkxJTktdID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkcmVuKSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGhyZWY6IG5vZGUuZGF0YS51cmkgfSwgY2hpbGRyZW4pOyB9LFxuICAgIF9hKTtcbnZhciBkZWZhdWx0TWFya1JlbmRlcmVycyA9IChfYiA9IHt9LFxuICAgIF9iW3JpY2hUZXh0VHlwZXMuTUFSS1MuQk9MRF0gPSBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImJcIiwgbnVsbCwgdGV4dCk7IH0sXG4gICAgX2JbcmljaFRleHRUeXBlcy5NQVJLUy5JVEFMSUNdID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpXCIsIG51bGwsIHRleHQpOyB9LFxuICAgIF9iW3JpY2hUZXh0VHlwZXMuTUFSS1MuVU5ERVJMSU5FXSA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwidVwiLCBudWxsLCB0ZXh0KTsgfSxcbiAgICBfYltyaWNoVGV4dFR5cGVzLk1BUktTLkNPREVdID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIG51bGwsIHRleHQpOyB9LFxuICAgIF9iW3JpY2hUZXh0VHlwZXMuTUFSS1MuU1VQRVJTQ1JJUFRdID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdXBcIiwgbnVsbCwgdGV4dCk7IH0sXG4gICAgX2JbcmljaFRleHRUeXBlcy5NQVJLUy5TVUJTQ1JJUFRdID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdWJcIiwgbnVsbCwgdGV4dCk7IH0sXG4gICAgX2JbcmljaFRleHRUeXBlcy5NQVJLUy5TVFJJS0VUSFJPVUdIXSA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic1wiLCBudWxsLCB0ZXh0KTsgfSxcbiAgICBfYik7XG5mdW5jdGlvbiBkZWZhdWx0SW5saW5lKHR5cGUsIG5vZGUpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBub2RlLmRhdGEudGFyZ2V0LnN5cy5pZCB9LFxuICAgICAgICBcInR5cGU6IFwiLFxuICAgICAgICBub2RlLm5vZGVUeXBlLFxuICAgICAgICBcIiBpZDogXCIsXG4gICAgICAgIG5vZGUuZGF0YS50YXJnZXQuc3lzLmlkKSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0SW5saW5lUmVzb3VyY2UodHlwZSwgbm9kZSkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBrZXk6IG5vZGUuZGF0YS50YXJnZXQuc3lzLnVybiB9LFxuICAgICAgICBcInR5cGU6IFwiLFxuICAgICAgICBub2RlLm5vZGVUeXBlLFxuICAgICAgICBcIiB1cm46IFwiLFxuICAgICAgICBub2RlLmRhdGEudGFyZ2V0LnN5cy51cm4pKTtcbn1cbi8qKlxuICogU2VyaWFsaXplIGEgQ29udGVudGZ1bCBSaWNoIFRleHQgYGRvY3VtZW50YCB0byBSZWFjdCB0cmVlXG4gKi9cbmZ1bmN0aW9uIGRvY3VtZW50VG9SZWFjdENvbXBvbmVudHMocmljaFRleHREb2N1bWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgaWYgKCFyaWNoVGV4dERvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTdHJpcCBlbXB0eSB0cmFpbGluZyBwYXJhZ3JhcGggaWYgZW5hYmxlZFxuICAgIHZhciBwcm9jZXNzZWREb2N1bWVudCA9IHJpY2hUZXh0RG9jdW1lbnQ7XG4gICAgaWYgKG9wdGlvbnMuc3RyaXBFbXB0eVRyYWlsaW5nUGFyYWdyYXBoKSB7XG4gICAgICAgIHByb2Nlc3NlZERvY3VtZW50ID0gcmljaFRleHRUeXBlcy5oZWxwZXJzLnN0cmlwRW1wdHlUcmFpbGluZ1BhcmFncmFwaEZyb21Eb2N1bWVudChyaWNoVGV4dERvY3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVUb1JlYWN0Q29tcG9uZW50KHByb2Nlc3NlZERvY3VtZW50LCB7XG4gICAgICAgIHJlbmRlck5vZGU6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0Tm9kZVJlbmRlcmVycyksIG9wdGlvbnMucmVuZGVyTm9kZSksXG4gICAgICAgIHJlbmRlck1hcms6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0TWFya1JlbmRlcmVycyksIG9wdGlvbnMucmVuZGVyTWFyayksXG4gICAgICAgIHJlbmRlclRleHQ6IG9wdGlvbnMucmVuZGVyVGV4dCxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSxcbiAgICB9KTtcbn1cblxuZXhwb3J0cy5kb2N1bWVudFRvUmVhY3RDb21wb25lbnRzID0gZG9jdW1lbnRUb1JlYWN0Q29tcG9uZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpY2gtdGV4dC1yZWFjdC1yZW5kZXJlci5lczUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@contentful/rich-text-react-renderer/dist/rich-text-react-renderer.es5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@contentful/rich-text-types/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@contentful/rich-text-types/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar isPlainObject = __webpack_require__(/*! is-plain-obj */ \"(rsc)/./node_modules/@contentful/rich-text-types/node_modules/is-plain-obj/index.js\");\n\n/**\n * Map of all Contentful block types. Blocks contain inline or block nodes.\n */\nexports.BLOCKS = void 0;\n(function (BLOCKS) {\n    BLOCKS[\"DOCUMENT\"] = \"document\";\n    BLOCKS[\"PARAGRAPH\"] = \"paragraph\";\n    BLOCKS[\"HEADING_1\"] = \"heading-1\";\n    BLOCKS[\"HEADING_2\"] = \"heading-2\";\n    BLOCKS[\"HEADING_3\"] = \"heading-3\";\n    BLOCKS[\"HEADING_4\"] = \"heading-4\";\n    BLOCKS[\"HEADING_5\"] = \"heading-5\";\n    BLOCKS[\"HEADING_6\"] = \"heading-6\";\n    BLOCKS[\"OL_LIST\"] = \"ordered-list\";\n    BLOCKS[\"UL_LIST\"] = \"unordered-list\";\n    BLOCKS[\"LIST_ITEM\"] = \"list-item\";\n    BLOCKS[\"HR\"] = \"hr\";\n    BLOCKS[\"QUOTE\"] = \"blockquote\";\n    BLOCKS[\"EMBEDDED_ENTRY\"] = \"embedded-entry-block\";\n    BLOCKS[\"EMBEDDED_ASSET\"] = \"embedded-asset-block\";\n    BLOCKS[\"EMBEDDED_RESOURCE\"] = \"embedded-resource-block\";\n    BLOCKS[\"TABLE\"] = \"table\";\n    BLOCKS[\"TABLE_ROW\"] = \"table-row\";\n    BLOCKS[\"TABLE_CELL\"] = \"table-cell\";\n    BLOCKS[\"TABLE_HEADER_CELL\"] = \"table-header-cell\";\n})(exports.BLOCKS || (exports.BLOCKS = {}));\n\n/**\n * Map of all Contentful inline types. Inline contain inline or text nodes.\n *\n * @note This should be kept in alphabetical order since the\n * [validation package](https://github.com/contentful/content-stack/tree/master/packages/validation)\n *  relies on the values being in a predictable order.\n */\nexports.INLINES = void 0;\n(function (INLINES) {\n    INLINES[\"ASSET_HYPERLINK\"] = \"asset-hyperlink\";\n    INLINES[\"EMBEDDED_ENTRY\"] = \"embedded-entry-inline\";\n    INLINES[\"EMBEDDED_RESOURCE\"] = \"embedded-resource-inline\";\n    INLINES[\"ENTRY_HYPERLINK\"] = \"entry-hyperlink\";\n    INLINES[\"HYPERLINK\"] = \"hyperlink\";\n    INLINES[\"RESOURCE_HYPERLINK\"] = \"resource-hyperlink\";\n})(exports.INLINES || (exports.INLINES = {}));\n\n/**\n * Map of all Contentful marks.\n */\nexports.MARKS = void 0;\n(function (MARKS) {\n    MARKS[\"BOLD\"] = \"bold\";\n    MARKS[\"ITALIC\"] = \"italic\";\n    MARKS[\"UNDERLINE\"] = \"underline\";\n    MARKS[\"CODE\"] = \"code\";\n    MARKS[\"SUPERSCRIPT\"] = \"superscript\";\n    MARKS[\"SUBSCRIPT\"] = \"subscript\";\n    MARKS[\"STRIKETHROUGH\"] = \"strikethrough\";\n})(exports.MARKS || (exports.MARKS = {}));\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar _a$1;\n/**\n * Array of all top level block types.\n * Only these block types can be the direct children of the document.\n */\nvar TOP_LEVEL_BLOCKS = [\n    exports.BLOCKS.PARAGRAPH,\n    exports.BLOCKS.HEADING_1,\n    exports.BLOCKS.HEADING_2,\n    exports.BLOCKS.HEADING_3,\n    exports.BLOCKS.HEADING_4,\n    exports.BLOCKS.HEADING_5,\n    exports.BLOCKS.HEADING_6,\n    exports.BLOCKS.OL_LIST,\n    exports.BLOCKS.UL_LIST,\n    exports.BLOCKS.HR,\n    exports.BLOCKS.QUOTE,\n    exports.BLOCKS.EMBEDDED_ENTRY,\n    exports.BLOCKS.EMBEDDED_ASSET,\n    exports.BLOCKS.EMBEDDED_RESOURCE,\n    exports.BLOCKS.TABLE,\n];\n/**\n * Array of all allowed block types inside list items\n */\nvar LIST_ITEM_BLOCKS = [\n    exports.BLOCKS.PARAGRAPH,\n    exports.BLOCKS.HEADING_1,\n    exports.BLOCKS.HEADING_2,\n    exports.BLOCKS.HEADING_3,\n    exports.BLOCKS.HEADING_4,\n    exports.BLOCKS.HEADING_5,\n    exports.BLOCKS.HEADING_6,\n    exports.BLOCKS.OL_LIST,\n    exports.BLOCKS.UL_LIST,\n    exports.BLOCKS.HR,\n    exports.BLOCKS.QUOTE,\n    exports.BLOCKS.EMBEDDED_ENTRY,\n    exports.BLOCKS.EMBEDDED_ASSET,\n    exports.BLOCKS.EMBEDDED_RESOURCE,\n];\nvar TABLE_BLOCKS = [\n    exports.BLOCKS.TABLE,\n    exports.BLOCKS.TABLE_ROW,\n    exports.BLOCKS.TABLE_CELL,\n    exports.BLOCKS.TABLE_HEADER_CELL,\n];\n/**\n * Array of all void block types\n */\nvar VOID_BLOCKS = [\n    exports.BLOCKS.HR,\n    exports.BLOCKS.EMBEDDED_ENTRY,\n    exports.BLOCKS.EMBEDDED_ASSET,\n    exports.BLOCKS.EMBEDDED_RESOURCE,\n];\n/**\n * Dictionary of all container block types, and the set block types they accept as children.\n *\n * Note: This does not include `[BLOCKS.DOCUMENT]: TOP_LEVEL_BLOCKS`\n */\nvar CONTAINERS = (_a$1 = {},\n    _a$1[exports.BLOCKS.OL_LIST] = [exports.BLOCKS.LIST_ITEM],\n    _a$1[exports.BLOCKS.UL_LIST] = [exports.BLOCKS.LIST_ITEM],\n    _a$1[exports.BLOCKS.LIST_ITEM] = LIST_ITEM_BLOCKS,\n    _a$1[exports.BLOCKS.QUOTE] = [exports.BLOCKS.PARAGRAPH],\n    _a$1[exports.BLOCKS.TABLE] = [exports.BLOCKS.TABLE_ROW],\n    _a$1[exports.BLOCKS.TABLE_ROW] = [exports.BLOCKS.TABLE_CELL, exports.BLOCKS.TABLE_HEADER_CELL],\n    _a$1[exports.BLOCKS.TABLE_CELL] = [exports.BLOCKS.PARAGRAPH, exports.BLOCKS.UL_LIST, exports.BLOCKS.OL_LIST],\n    _a$1[exports.BLOCKS.TABLE_HEADER_CELL] = [exports.BLOCKS.PARAGRAPH],\n    _a$1);\n/**\n * Array of all heading levels\n */\nvar HEADINGS = [\n    exports.BLOCKS.HEADING_1,\n    exports.BLOCKS.HEADING_2,\n    exports.BLOCKS.HEADING_3,\n    exports.BLOCKS.HEADING_4,\n    exports.BLOCKS.HEADING_5,\n    exports.BLOCKS.HEADING_6,\n];\n/**\n * Array of all block types that may contain text and inline nodes.\n */\nvar TEXT_CONTAINERS = __spreadArray([exports.BLOCKS.PARAGRAPH], HEADINGS, true);\n/**\n * Node types before `tables` release.\n */\nvar V1_NODE_TYPES = [\n    exports.BLOCKS.DOCUMENT,\n    exports.BLOCKS.PARAGRAPH,\n    exports.BLOCKS.HEADING_1,\n    exports.BLOCKS.HEADING_2,\n    exports.BLOCKS.HEADING_3,\n    exports.BLOCKS.HEADING_4,\n    exports.BLOCKS.HEADING_5,\n    exports.BLOCKS.HEADING_6,\n    exports.BLOCKS.OL_LIST,\n    exports.BLOCKS.UL_LIST,\n    exports.BLOCKS.LIST_ITEM,\n    exports.BLOCKS.HR,\n    exports.BLOCKS.QUOTE,\n    exports.BLOCKS.EMBEDDED_ENTRY,\n    exports.BLOCKS.EMBEDDED_ASSET,\n    exports.INLINES.HYPERLINK,\n    exports.INLINES.ENTRY_HYPERLINK,\n    exports.INLINES.ASSET_HYPERLINK,\n    exports.INLINES.EMBEDDED_ENTRY,\n    'text',\n];\n/**\n * Marks before `superscript` & `subscript` release.\n */\nvar V1_MARKS = [exports.MARKS.BOLD, exports.MARKS.CODE, exports.MARKS.ITALIC, exports.MARKS.UNDERLINE];\n\n/**\n * A rich text document considered to be empty.\n * Any other document structure than this is not considered empty.\n */\nvar EMPTY_DOCUMENT = {\n    nodeType: exports.BLOCKS.DOCUMENT,\n    data: {},\n    content: [\n        {\n            nodeType: exports.BLOCKS.PARAGRAPH,\n            data: {},\n            content: [\n                {\n                    nodeType: 'text',\n                    value: '',\n                    marks: [],\n                    data: {},\n                },\n            ],\n        },\n    ],\n};\n\n/**\n * Tiny replacement for Object.values(object).includes(key) to\n * avoid including CoreJS polyfills\n */\nfunction hasValue(obj, value) {\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (value === obj[key]) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Checks if the node is an instance of Inline.\n */\nfunction isInline(node) {\n    return hasValue(exports.INLINES, node.nodeType);\n}\n/**\n * Checks if the node is an instance of Block.\n */\nfunction isBlock(node) {\n    return hasValue(exports.BLOCKS, node.nodeType);\n}\n/**\n * Checks if the node is an instance of Text.\n */\nfunction isText(node) {\n    return node.nodeType === 'text';\n}\n/**\n * Checks if a paragraph is empty (has only one child and that child is an empty string text node)\n */\nfunction isEmptyParagraph(node) {\n    if (node.nodeType !== exports.BLOCKS.PARAGRAPH) {\n        return false;\n    }\n    if (node.content.length !== 1) {\n        return false;\n    }\n    var textNode = node.content[0];\n    return textNode.nodeType === 'text' && textNode.value === '';\n}\nfunction isValidDocument(document) {\n    return (document != null &&\n        typeof document === 'object' &&\n        'content' in document &&\n        Array.isArray(document.content));\n}\nvar MIN_NODES_FOR_STRIPPING = 2;\n/**\n * Strips empty trailing paragraph from a document if enabled\n * @param document - The rich text document to process\n * @returns A new document with the empty trailing paragraph removed (if conditions are met)\n * @example\n * const processedDoc = stripEmptyTrailingParagraphFromDocument(document);\n */\nfunction stripEmptyTrailingParagraphFromDocument(document) {\n    if (!isValidDocument(document) || document.content.length < MIN_NODES_FOR_STRIPPING) {\n        return document;\n    }\n    var lastNode = document.content[document.content.length - 1];\n    // Check if the last node is an empty paragraph\n    if (isEmptyParagraph(lastNode)) {\n        return __assign(__assign({}, document), { content: document.content.slice(0, -1) });\n    }\n    return document;\n}\n\nvar helpers = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isBlock: isBlock,\n  isEmptyParagraph: isEmptyParagraph,\n  isInline: isInline,\n  isText: isText,\n  stripEmptyTrailingParagraphFromDocument: stripEmptyTrailingParagraphFromDocument\n});\n\nvar typeMismatchError = function (_a) {\n    var path = _a.path, property = _a.property, typeName = _a.typeName, value = _a.value;\n    return {\n        details: \"The type of \\\"\".concat(property, \"\\\" is incorrect, expected type: \").concat(typeName),\n        name: 'type',\n        path: path.toArray(),\n        type: typeName,\n        value: value,\n    };\n};\nvar minSizeError = function (_a) {\n    var min = _a.min, value = _a.value, path = _a.path;\n    return {\n        name: 'size',\n        min: min,\n        path: path.toArray(),\n        details: \"Size must be at least \".concat(min),\n        value: value,\n    };\n};\nvar maxSizeError = function (_a) {\n    var max = _a.max, value = _a.value, path = _a.path;\n    return {\n        name: 'size',\n        max: max,\n        path: path.toArray(),\n        details: \"Size must be at most \".concat(max),\n        value: value,\n    };\n};\nvar enumError = function (_a) {\n    var expected = _a.expected, value = _a.value, path = _a.path;\n    return {\n        details: \"Value must be one of expected values\",\n        name: 'in',\n        expected: __spreadArray([], expected, true).sort(),\n        path: path.toArray(),\n        value: value,\n    };\n};\nvar unknownPropertyError = function (_a) {\n    var property = _a.property, path = _a.path;\n    return {\n        details: \"The property \\\"\".concat(property, \"\\\" is not expected\"),\n        name: 'unexpected',\n        path: path.toArray(),\n    };\n};\nvar requiredPropertyError = function (_a) {\n    var property = _a.property, path = _a.path;\n    return {\n        details: \"The property \\\"\".concat(property, \"\\\" is required here\"),\n        name: 'required',\n        path: path.toArray(),\n    };\n};\n\nvar ObjectAssertion = /** @class */ (function () {\n    function ObjectAssertion(obj, path) {\n        var _this = this;\n        this.obj = obj;\n        this.path = path;\n        this._errors = [];\n        this.catch = function () {\n            var _a;\n            var errors = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                errors[_i] = arguments[_i];\n            }\n            (_a = _this._errors).push.apply(_a, errors);\n        };\n        /**\n         * Asserts the key exists in the object. You probably shouldn't call this\n         * function directly. Instead, use `$.object`, `$.number`, `$.string`, etc.\n         */\n        this.exists = function (key) {\n            if (key in _this.obj) {\n                return true;\n            }\n            _this.catch(requiredPropertyError({\n                property: key,\n                path: _this.path.of(key),\n            }));\n            return false;\n        };\n        /**\n         * Asserts the key exists in the object and its value is a plain object. if\n         * no key is provided, it asserts the object itself.\n         */\n        this.object = function (key) {\n            var _a;\n            var value = key ? _this.obj[key] : _this.obj;\n            if (key) {\n                if (!_this.exists(key)) {\n                    return false;\n                }\n            }\n            if (isPlainObject(value)) {\n                return true;\n            }\n            var path = key ? _this.path.of(key) : _this.path;\n            var property = (_a = key !== null && key !== void 0 ? key : _this.path.last()) !== null && _a !== void 0 ? _a : 'value';\n            _this.catch(typeMismatchError({\n                typeName: 'Object',\n                property: property,\n                path: path,\n                value: value,\n            }));\n            return false;\n        };\n        /**\n         * Asserts the key exists in the object and its value is a string.\n         */\n        this.string = function (key) {\n            var value = _this.obj[key];\n            if (key && !_this.exists(key)) {\n                return false;\n            }\n            if (typeof value === 'string') {\n                return true;\n            }\n            _this.catch(typeMismatchError({\n                typeName: 'String',\n                property: key,\n                path: _this.path.of(key),\n                value: value,\n            }));\n            return false;\n        };\n        /**\n         * Asserts the key exists in the object and its value is a number.\n         */\n        this.number = function (key, optional) {\n            var value = _this.obj[key];\n            if (optional && !(key in _this.obj)) {\n                return true;\n            }\n            if (!_this.exists(key)) {\n                return false;\n            }\n            if (typeof value === 'number' && !Number.isNaN(value)) {\n                return true;\n            }\n            _this.catch(typeMismatchError({\n                typeName: 'Number',\n                property: key,\n                path: _this.path.of(key),\n                value: value,\n            }));\n            return false;\n        };\n        /**\n         * Asserts the key exists in the object and its value is an array. You don't\n         * need to manually call this function before `$.each` or `$.maxLength`.\n         */\n        this.array = function (key) {\n            var value = _this.obj[key];\n            if (key && !_this.exists(key)) {\n                return false;\n            }\n            if (Array.isArray(value)) {\n                return true;\n            }\n            _this.catch(typeMismatchError({\n                typeName: 'Array',\n                property: key,\n                path: _this.path.of(key),\n                value: value,\n            }));\n            return false;\n        };\n        /**\n         * Asserts the value of the key is one of the expected values.\n         */\n        this.enum = function (key, expected) {\n            var value = _this.obj[key];\n            if (typeof value === 'string' && expected.includes(value)) {\n                return true;\n            }\n            _this.catch(enumError({\n                expected: expected,\n                value: value,\n                path: _this.path.of(key),\n            }));\n            return false;\n        };\n        /**\n         * Asserts the array value of the object key is empty. If the value isn't an\n         * array, the function captures a type error and returns false.\n         */\n        this.empty = function (key) {\n            if (!_this.array(key)) {\n                return false;\n            }\n            var value = _this.obj[key];\n            if (value.length === 0) {\n                return true;\n            }\n            _this.catch(maxSizeError({\n                max: 0,\n                value: value,\n                path: _this.path.of(key),\n            }));\n            return false;\n        };\n        /**\n         * Asserts the length of the value of the object key is at least `min`. If the\n         * value isn't an array, the function captures a type error and returns false.\n         */\n        this.minLength = function (key, min) {\n            if (!_this.array(key)) {\n                return false;\n            }\n            var value = _this.obj[key];\n            if (value.length >= min) {\n                return true;\n            }\n            _this.catch(minSizeError({\n                min: min,\n                value: value,\n                path: _this.path.of(key),\n            }));\n            return false;\n        };\n        /**\n         * Asserts the object has no additional properties other than the ones\n         * specified\n         */\n        this.noAdditionalProperties = function (properties) {\n            var unknowns = Object.keys(_this.obj)\n                .sort()\n                .filter(function (key) { return !properties.includes(key); });\n            unknowns.forEach(function (property) {\n                return _this.catch(unknownPropertyError({\n                    property: property,\n                    path: _this.path.of(property),\n                }));\n            });\n            return unknowns.length === 0;\n        };\n        /**\n         * Iterates over the value of the key and assert each item. If the value isn't\n         * an array, the function captures a type error and safely exits.\n         *\n         * To maintain compatibility with previous implementation, we stop early if we\n         * find any errors.\n         */\n        this.each = function (key, assert) {\n            if (!_this.array(key)) {\n                return;\n            }\n            var value = _this.obj[key];\n            var foundErrors = false;\n            value.forEach(function (item, index) {\n                if (foundErrors) {\n                    return;\n                }\n                var errors = assert(item, _this.path.of(key).of(index));\n                if (errors.length > 0) {\n                    foundErrors = true;\n                }\n                _this.catch.apply(_this, errors);\n            });\n        };\n    }\n    Object.defineProperty(ObjectAssertion.prototype, \"errors\", {\n        get: function () {\n            var _this = this;\n            var serializeError = function (error) {\n                return JSON.stringify({\n                    details: error.details,\n                    path: error.path,\n                });\n            };\n            return this._errors.filter(function (error, index) {\n                return _this._errors.findIndex(function (step) { return serializeError(error) === serializeError(step); }) === index;\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ObjectAssertion;\n}());\n\nvar VOID_CONTENT = [];\nvar NodeAssertion = /** @class */ (function () {\n    function NodeAssertion(contentRule, validateData) {\n        this.contentRule = contentRule;\n        this.validateData = validateData;\n    }\n    NodeAssertion.prototype.assert = function (node, path) {\n        var _a, _b;\n        var $ = new ObjectAssertion(node, path);\n        if (!$.object()) {\n            return $.errors;\n        }\n        $.noAdditionalProperties(['nodeType', 'data', 'content']);\n        var _c = Array.isArray(this.contentRule)\n            ? {\n                nodeTypes: this.contentRule,\n            }\n            : this.contentRule(node, path), nodeTypes = _c.nodeTypes, _d = _c.min, min = _d === void 0 ? 0 : _d;\n        if (nodeTypes.length === 0 && min > 0) {\n            throw new Error(\"Invalid content rule. Cannot have enforce a 'min' of \".concat(min, \" with no nodeTypes\"));\n        }\n        $.minLength('content', min);\n        // Is void\n        if (nodeTypes.length === 0) {\n            $.empty('content');\n        }\n        // Ensure content nodes have valid nodeTypes without validating the full\n        // shape which is something that's only done later if the current node is\n        // valid.\n        else {\n            $.each('content', function (item, path) {\n                var item$ = new ObjectAssertion(item, path);\n                if (!item$.object()) {\n                    return item$.errors;\n                }\n                item$.enum('nodeType', nodeTypes);\n                return item$.errors;\n            });\n        }\n        if ($.object('data')) {\n            var dataErrors = (_b = (_a = this.validateData) === null || _a === void 0 ? void 0 : _a.call(this, node.data, path.of('data'))) !== null && _b !== void 0 ? _b : [];\n            $.catch.apply($, dataErrors);\n        }\n        return $.errors;\n    };\n    return NodeAssertion;\n}());\nvar EntityLinkAssertion = /** @class */ (function (_super) {\n    __extends(EntityLinkAssertion, _super);\n    function EntityLinkAssertion(linkType, contentNodeTypes) {\n        var _this = _super.call(this, contentNodeTypes, function (data, path) { return _this.assertLink(data, path); }) || this;\n        _this.linkType = linkType;\n        _this.assertLink = function (data, path) {\n            var $ = new ObjectAssertion(data, path);\n            if ($.object('target')) {\n                var sys$ = new ObjectAssertion(data.target.sys, path.of('target').of('sys'));\n                if (sys$.object()) {\n                    sys$.enum('type', [_this.type]);\n                    sys$.enum('linkType', [_this.linkType]);\n                    if (_this.type === 'Link') {\n                        sys$.string('id');\n                        sys$.noAdditionalProperties(['type', 'linkType', 'id']);\n                    }\n                    else if (_this.type === 'ResourceLink') {\n                        sys$.string('urn');\n                        sys$.noAdditionalProperties(['type', 'linkType', 'urn']);\n                    }\n                }\n                $.catch.apply($, sys$.errors);\n            }\n            $.noAdditionalProperties(['target']);\n            return $.errors;\n        };\n        _this.type = _this.linkType.startsWith('Contentful:') ? 'ResourceLink' : 'Link';\n        return _this;\n    }\n    return EntityLinkAssertion;\n}(NodeAssertion));\nvar HyperLinkAssertion = /** @class */ (function (_super) {\n    __extends(HyperLinkAssertion, _super);\n    function HyperLinkAssertion() {\n        var _this = _super.call(this, ['text'], function (data, path) { return _this.assertLink(data, path); }) || this;\n        _this.assertLink = function (data, path) {\n            var $ = new ObjectAssertion(data, path);\n            $.string('uri');\n            $.noAdditionalProperties(['uri']);\n            return $.errors;\n        };\n        return _this;\n    }\n    return HyperLinkAssertion;\n}(NodeAssertion));\nvar assert = function (contentRule, validateData) {\n    return new NodeAssertion(contentRule, validateData);\n};\nvar assertLink = function (linkType, contentRule) {\n    return new EntityLinkAssertion(linkType, contentRule);\n};\n\nvar Path = /** @class */ (function () {\n    function Path(path) {\n        if (path === void 0) { path = []; }\n        var _this = this;\n        this.path = path;\n        this.of = function (element) {\n            return new Path(__spreadArray(__spreadArray([], _this.path, true), [element], false));\n        };\n        this.isRoot = function () {\n            return _this.path.length === 0;\n        };\n        this.last = function () {\n            return _this.path[_this.path.length - 1];\n        };\n        this.toArray = function () {\n            return _this.path;\n        };\n    }\n    return Path;\n}());\n\nfunction assertText(text, path) {\n    var $ = new ObjectAssertion(text, path);\n    if (!$.object()) {\n        return $.errors;\n    }\n    $.noAdditionalProperties(['nodeType', 'data', 'value', 'marks']);\n    $.object('data');\n    $.each('marks', function (mark, path) {\n        var mark$ = new ObjectAssertion(mark, path);\n        if (!mark$.object()) {\n            return mark$.errors;\n        }\n        // For historical reasons, we don't explicitly check for supported marks\n        // e.g. bold, italic ..etc. This makes it possible for a customer to add\n        // custom marks\n        mark$.string('type');\n        return mark$.errors;\n    });\n    $.string('value');\n    return $.errors;\n}\n\nvar _a;\nvar assertInlineOrText = assert(__spreadArray(__spreadArray([], Object.values(exports.INLINES), true), ['text'], false).sort());\nvar assertList = assert([exports.BLOCKS.LIST_ITEM]);\nvar assertVoidEntryLink = assertLink('Entry', VOID_CONTENT);\nvar assertTableCell = assert(function () { return ({\n    nodeTypes: [exports.BLOCKS.PARAGRAPH],\n    min: 1,\n}); }, function (data, path) {\n    var $ = new ObjectAssertion(data, path);\n    $.noAdditionalProperties(['colspan', 'rowspan']);\n    $.number('colspan', true);\n    $.number('rowspan', true);\n    return $.errors;\n});\nvar nodeValidator = (_a = {},\n    _a[exports.BLOCKS.DOCUMENT] = assert(TOP_LEVEL_BLOCKS),\n    _a[exports.BLOCKS.PARAGRAPH] = assertInlineOrText,\n    _a[exports.BLOCKS.HEADING_1] = assertInlineOrText,\n    _a[exports.BLOCKS.HEADING_2] = assertInlineOrText,\n    _a[exports.BLOCKS.HEADING_3] = assertInlineOrText,\n    _a[exports.BLOCKS.HEADING_4] = assertInlineOrText,\n    _a[exports.BLOCKS.HEADING_5] = assertInlineOrText,\n    _a[exports.BLOCKS.HEADING_6] = assertInlineOrText,\n    _a[exports.BLOCKS.QUOTE] = assert(CONTAINERS[exports.BLOCKS.QUOTE]),\n    _a[exports.BLOCKS.EMBEDDED_ENTRY] = assertVoidEntryLink,\n    _a[exports.BLOCKS.EMBEDDED_ASSET] = assertLink('Asset', VOID_CONTENT),\n    _a[exports.BLOCKS.EMBEDDED_RESOURCE] = assertLink('Contentful:Entry', VOID_CONTENT),\n    _a[exports.BLOCKS.HR] = assert(VOID_CONTENT),\n    _a[exports.BLOCKS.OL_LIST] = assertList,\n    _a[exports.BLOCKS.UL_LIST] = assertList,\n    _a[exports.BLOCKS.LIST_ITEM] = assert(__spreadArray([], LIST_ITEM_BLOCKS, true).sort()),\n    _a[exports.BLOCKS.TABLE] = assert(function () { return ({\n        nodeTypes: [exports.BLOCKS.TABLE_ROW],\n        min: 1,\n    }); }),\n    _a[exports.BLOCKS.TABLE_ROW] = assert(function () { return ({\n        nodeTypes: [exports.BLOCKS.TABLE_CELL, exports.BLOCKS.TABLE_HEADER_CELL],\n        min: 1,\n    }); }),\n    _a[exports.BLOCKS.TABLE_CELL] = assertTableCell,\n    _a[exports.BLOCKS.TABLE_HEADER_CELL] = assertTableCell,\n    _a[exports.INLINES.HYPERLINK] = new HyperLinkAssertion(),\n    _a[exports.INLINES.EMBEDDED_ENTRY] = assertVoidEntryLink,\n    _a[exports.INLINES.EMBEDDED_RESOURCE] = assertLink('Contentful:Entry', VOID_CONTENT),\n    _a[exports.INLINES.ENTRY_HYPERLINK] = assertLink('Entry', ['text']),\n    _a[exports.INLINES.ASSET_HYPERLINK] = assertLink('Asset', ['text']),\n    _a[exports.INLINES.RESOURCE_HYPERLINK] = assertLink('Contentful:Entry', ['text']),\n    _a);\nfunction validateNode(node, path) {\n    if (node.nodeType === 'text') {\n        return assertText(node, path);\n    }\n    var errors = nodeValidator[node.nodeType].assert(node, path);\n    if (errors.length > 0) {\n        return errors;\n    }\n    var $ = new ObjectAssertion(node, path);\n    $.each('content', function (item, path) {\n        // We already know those are valid nodes thanks to the assertion done in\n        // the NodeAssertion class\n        return validateNode(item, path);\n    });\n    return $.errors;\n}\nvar validateRichTextDocument = function (document) {\n    var path = new Path();\n    var $ = new ObjectAssertion(document, path);\n    if ($.object()) {\n        $.enum('nodeType', [exports.BLOCKS.DOCUMENT]);\n    }\n    if ($.errors.length > 0) {\n        return $.errors;\n    }\n    return validateNode(document, path);\n};\n\nexports.CONTAINERS = CONTAINERS;\nexports.EMPTY_DOCUMENT = EMPTY_DOCUMENT;\nexports.HEADINGS = HEADINGS;\nexports.LIST_ITEM_BLOCKS = LIST_ITEM_BLOCKS;\nexports.TABLE_BLOCKS = TABLE_BLOCKS;\nexports.TEXT_CONTAINERS = TEXT_CONTAINERS;\nexports.TOP_LEVEL_BLOCKS = TOP_LEVEL_BLOCKS;\nexports.V1_MARKS = V1_MARKS;\nexports.V1_NODE_TYPES = V1_NODE_TYPES;\nexports.VOID_BLOCKS = VOID_BLOCKS;\nexports.helpers = helpers;\nexports.validateRichTextDocument = validateRichTextDocument;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvbnRlbnRmdWwvcmljaC10ZXh0LXR5cGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMseUdBQWM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQixjQUFjLEtBQUs7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0IsZUFBZSxLQUFLOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CLGFBQWEsS0FBSzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWUsd0NBQXdDO0FBQzFGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1DQUFtQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUVBQWlFLHdEQUF3RDtBQUN6SCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLHNDQUFzQztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxzQ0FBc0M7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNULHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy91c2VyL0Rlc2t0b3AvcG9ydHNtb3V0aC9ub2RlX21vZHVsZXMvQGNvbnRlbnRmdWwvcmljaC10ZXh0LXR5cGVzL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iaicpO1xuXG4vKipcbiAqIE1hcCBvZiBhbGwgQ29udGVudGZ1bCBibG9jayB0eXBlcy4gQmxvY2tzIGNvbnRhaW4gaW5saW5lIG9yIGJsb2NrIG5vZGVzLlxuICovXG5leHBvcnRzLkJMT0NLUyA9IHZvaWQgMDtcbihmdW5jdGlvbiAoQkxPQ0tTKSB7XG4gICAgQkxPQ0tTW1wiRE9DVU1FTlRcIl0gPSBcImRvY3VtZW50XCI7XG4gICAgQkxPQ0tTW1wiUEFSQUdSQVBIXCJdID0gXCJwYXJhZ3JhcGhcIjtcbiAgICBCTE9DS1NbXCJIRUFESU5HXzFcIl0gPSBcImhlYWRpbmctMVwiO1xuICAgIEJMT0NLU1tcIkhFQURJTkdfMlwiXSA9IFwiaGVhZGluZy0yXCI7XG4gICAgQkxPQ0tTW1wiSEVBRElOR18zXCJdID0gXCJoZWFkaW5nLTNcIjtcbiAgICBCTE9DS1NbXCJIRUFESU5HXzRcIl0gPSBcImhlYWRpbmctNFwiO1xuICAgIEJMT0NLU1tcIkhFQURJTkdfNVwiXSA9IFwiaGVhZGluZy01XCI7XG4gICAgQkxPQ0tTW1wiSEVBRElOR182XCJdID0gXCJoZWFkaW5nLTZcIjtcbiAgICBCTE9DS1NbXCJPTF9MSVNUXCJdID0gXCJvcmRlcmVkLWxpc3RcIjtcbiAgICBCTE9DS1NbXCJVTF9MSVNUXCJdID0gXCJ1bm9yZGVyZWQtbGlzdFwiO1xuICAgIEJMT0NLU1tcIkxJU1RfSVRFTVwiXSA9IFwibGlzdC1pdGVtXCI7XG4gICAgQkxPQ0tTW1wiSFJcIl0gPSBcImhyXCI7XG4gICAgQkxPQ0tTW1wiUVVPVEVcIl0gPSBcImJsb2NrcXVvdGVcIjtcbiAgICBCTE9DS1NbXCJFTUJFRERFRF9FTlRSWVwiXSA9IFwiZW1iZWRkZWQtZW50cnktYmxvY2tcIjtcbiAgICBCTE9DS1NbXCJFTUJFRERFRF9BU1NFVFwiXSA9IFwiZW1iZWRkZWQtYXNzZXQtYmxvY2tcIjtcbiAgICBCTE9DS1NbXCJFTUJFRERFRF9SRVNPVVJDRVwiXSA9IFwiZW1iZWRkZWQtcmVzb3VyY2UtYmxvY2tcIjtcbiAgICBCTE9DS1NbXCJUQUJMRVwiXSA9IFwidGFibGVcIjtcbiAgICBCTE9DS1NbXCJUQUJMRV9ST1dcIl0gPSBcInRhYmxlLXJvd1wiO1xuICAgIEJMT0NLU1tcIlRBQkxFX0NFTExcIl0gPSBcInRhYmxlLWNlbGxcIjtcbiAgICBCTE9DS1NbXCJUQUJMRV9IRUFERVJfQ0VMTFwiXSA9IFwidGFibGUtaGVhZGVyLWNlbGxcIjtcbn0pKGV4cG9ydHMuQkxPQ0tTIHx8IChleHBvcnRzLkJMT0NLUyA9IHt9KSk7XG5cbi8qKlxuICogTWFwIG9mIGFsbCBDb250ZW50ZnVsIGlubGluZSB0eXBlcy4gSW5saW5lIGNvbnRhaW4gaW5saW5lIG9yIHRleHQgbm9kZXMuXG4gKlxuICogQG5vdGUgVGhpcyBzaG91bGQgYmUga2VwdCBpbiBhbHBoYWJldGljYWwgb3JkZXIgc2luY2UgdGhlXG4gKiBbdmFsaWRhdGlvbiBwYWNrYWdlXShodHRwczovL2dpdGh1Yi5jb20vY29udGVudGZ1bC9jb250ZW50LXN0YWNrL3RyZWUvbWFzdGVyL3BhY2thZ2VzL3ZhbGlkYXRpb24pXG4gKiAgcmVsaWVzIG9uIHRoZSB2YWx1ZXMgYmVpbmcgaW4gYSBwcmVkaWN0YWJsZSBvcmRlci5cbiAqL1xuZXhwb3J0cy5JTkxJTkVTID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChJTkxJTkVTKSB7XG4gICAgSU5MSU5FU1tcIkFTU0VUX0hZUEVSTElOS1wiXSA9IFwiYXNzZXQtaHlwZXJsaW5rXCI7XG4gICAgSU5MSU5FU1tcIkVNQkVEREVEX0VOVFJZXCJdID0gXCJlbWJlZGRlZC1lbnRyeS1pbmxpbmVcIjtcbiAgICBJTkxJTkVTW1wiRU1CRURERURfUkVTT1VSQ0VcIl0gPSBcImVtYmVkZGVkLXJlc291cmNlLWlubGluZVwiO1xuICAgIElOTElORVNbXCJFTlRSWV9IWVBFUkxJTktcIl0gPSBcImVudHJ5LWh5cGVybGlua1wiO1xuICAgIElOTElORVNbXCJIWVBFUkxJTktcIl0gPSBcImh5cGVybGlua1wiO1xuICAgIElOTElORVNbXCJSRVNPVVJDRV9IWVBFUkxJTktcIl0gPSBcInJlc291cmNlLWh5cGVybGlua1wiO1xufSkoZXhwb3J0cy5JTkxJTkVTIHx8IChleHBvcnRzLklOTElORVMgPSB7fSkpO1xuXG4vKipcbiAqIE1hcCBvZiBhbGwgQ29udGVudGZ1bCBtYXJrcy5cbiAqL1xuZXhwb3J0cy5NQVJLUyA9IHZvaWQgMDtcbihmdW5jdGlvbiAoTUFSS1MpIHtcbiAgICBNQVJLU1tcIkJPTERcIl0gPSBcImJvbGRcIjtcbiAgICBNQVJLU1tcIklUQUxJQ1wiXSA9IFwiaXRhbGljXCI7XG4gICAgTUFSS1NbXCJVTkRFUkxJTkVcIl0gPSBcInVuZGVybGluZVwiO1xuICAgIE1BUktTW1wiQ09ERVwiXSA9IFwiY29kZVwiO1xuICAgIE1BUktTW1wiU1VQRVJTQ1JJUFRcIl0gPSBcInN1cGVyc2NyaXB0XCI7XG4gICAgTUFSS1NbXCJTVUJTQ1JJUFRcIl0gPSBcInN1YnNjcmlwdFwiO1xuICAgIE1BUktTW1wiU1RSSUtFVEhST1VHSFwiXSA9IFwic3RyaWtldGhyb3VnaFwiO1xufSkoZXhwb3J0cy5NQVJLUyB8fCAoZXhwb3J0cy5NQVJLUyA9IHt9KSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIF9hJDE7XG4vKipcbiAqIEFycmF5IG9mIGFsbCB0b3AgbGV2ZWwgYmxvY2sgdHlwZXMuXG4gKiBPbmx5IHRoZXNlIGJsb2NrIHR5cGVzIGNhbiBiZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoZSBkb2N1bWVudC5cbiAqL1xudmFyIFRPUF9MRVZFTF9CTE9DS1MgPSBbXG4gICAgZXhwb3J0cy5CTE9DS1MuUEFSQUdSQVBILFxuICAgIGV4cG9ydHMuQkxPQ0tTLkhFQURJTkdfMSxcbiAgICBleHBvcnRzLkJMT0NLUy5IRUFESU5HXzIsXG4gICAgZXhwb3J0cy5CTE9DS1MuSEVBRElOR18zLFxuICAgIGV4cG9ydHMuQkxPQ0tTLkhFQURJTkdfNCxcbiAgICBleHBvcnRzLkJMT0NLUy5IRUFESU5HXzUsXG4gICAgZXhwb3J0cy5CTE9DS1MuSEVBRElOR182LFxuICAgIGV4cG9ydHMuQkxPQ0tTLk9MX0xJU1QsXG4gICAgZXhwb3J0cy5CTE9DS1MuVUxfTElTVCxcbiAgICBleHBvcnRzLkJMT0NLUy5IUixcbiAgICBleHBvcnRzLkJMT0NLUy5RVU9URSxcbiAgICBleHBvcnRzLkJMT0NLUy5FTUJFRERFRF9FTlRSWSxcbiAgICBleHBvcnRzLkJMT0NLUy5FTUJFRERFRF9BU1NFVCxcbiAgICBleHBvcnRzLkJMT0NLUy5FTUJFRERFRF9SRVNPVVJDRSxcbiAgICBleHBvcnRzLkJMT0NLUy5UQUJMRSxcbl07XG4vKipcbiAqIEFycmF5IG9mIGFsbCBhbGxvd2VkIGJsb2NrIHR5cGVzIGluc2lkZSBsaXN0IGl0ZW1zXG4gKi9cbnZhciBMSVNUX0lURU1fQkxPQ0tTID0gW1xuICAgIGV4cG9ydHMuQkxPQ0tTLlBBUkFHUkFQSCxcbiAgICBleHBvcnRzLkJMT0NLUy5IRUFESU5HXzEsXG4gICAgZXhwb3J0cy5CTE9DS1MuSEVBRElOR18yLFxuICAgIGV4cG9ydHMuQkxPQ0tTLkhFQURJTkdfMyxcbiAgICBleHBvcnRzLkJMT0NLUy5IRUFESU5HXzQsXG4gICAgZXhwb3J0cy5CTE9DS1MuSEVBRElOR181LFxuICAgIGV4cG9ydHMuQkxPQ0tTLkhFQURJTkdfNixcbiAgICBleHBvcnRzLkJMT0NLUy5PTF9MSVNULFxuICAgIGV4cG9ydHMuQkxPQ0tTLlVMX0xJU1QsXG4gICAgZXhwb3J0cy5CTE9DS1MuSFIsXG4gICAgZXhwb3J0cy5CTE9DS1MuUVVPVEUsXG4gICAgZXhwb3J0cy5CTE9DS1MuRU1CRURERURfRU5UUlksXG4gICAgZXhwb3J0cy5CTE9DS1MuRU1CRURERURfQVNTRVQsXG4gICAgZXhwb3J0cy5CTE9DS1MuRU1CRURERURfUkVTT1VSQ0UsXG5dO1xudmFyIFRBQkxFX0JMT0NLUyA9IFtcbiAgICBleHBvcnRzLkJMT0NLUy5UQUJMRSxcbiAgICBleHBvcnRzLkJMT0NLUy5UQUJMRV9ST1csXG4gICAgZXhwb3J0cy5CTE9DS1MuVEFCTEVfQ0VMTCxcbiAgICBleHBvcnRzLkJMT0NLUy5UQUJMRV9IRUFERVJfQ0VMTCxcbl07XG4vKipcbiAqIEFycmF5IG9mIGFsbCB2b2lkIGJsb2NrIHR5cGVzXG4gKi9cbnZhciBWT0lEX0JMT0NLUyA9IFtcbiAgICBleHBvcnRzLkJMT0NLUy5IUixcbiAgICBleHBvcnRzLkJMT0NLUy5FTUJFRERFRF9FTlRSWSxcbiAgICBleHBvcnRzLkJMT0NLUy5FTUJFRERFRF9BU1NFVCxcbiAgICBleHBvcnRzLkJMT0NLUy5FTUJFRERFRF9SRVNPVVJDRSxcbl07XG4vKipcbiAqIERpY3Rpb25hcnkgb2YgYWxsIGNvbnRhaW5lciBibG9jayB0eXBlcywgYW5kIHRoZSBzZXQgYmxvY2sgdHlwZXMgdGhleSBhY2NlcHQgYXMgY2hpbGRyZW4uXG4gKlxuICogTm90ZTogVGhpcyBkb2VzIG5vdCBpbmNsdWRlIGBbQkxPQ0tTLkRPQ1VNRU5UXTogVE9QX0xFVkVMX0JMT0NLU2BcbiAqL1xudmFyIENPTlRBSU5FUlMgPSAoX2EkMSA9IHt9LFxuICAgIF9hJDFbZXhwb3J0cy5CTE9DS1MuT0xfTElTVF0gPSBbZXhwb3J0cy5CTE9DS1MuTElTVF9JVEVNXSxcbiAgICBfYSQxW2V4cG9ydHMuQkxPQ0tTLlVMX0xJU1RdID0gW2V4cG9ydHMuQkxPQ0tTLkxJU1RfSVRFTV0sXG4gICAgX2EkMVtleHBvcnRzLkJMT0NLUy5MSVNUX0lURU1dID0gTElTVF9JVEVNX0JMT0NLUyxcbiAgICBfYSQxW2V4cG9ydHMuQkxPQ0tTLlFVT1RFXSA9IFtleHBvcnRzLkJMT0NLUy5QQVJBR1JBUEhdLFxuICAgIF9hJDFbZXhwb3J0cy5CTE9DS1MuVEFCTEVdID0gW2V4cG9ydHMuQkxPQ0tTLlRBQkxFX1JPV10sXG4gICAgX2EkMVtleHBvcnRzLkJMT0NLUy5UQUJMRV9ST1ddID0gW2V4cG9ydHMuQkxPQ0tTLlRBQkxFX0NFTEwsIGV4cG9ydHMuQkxPQ0tTLlRBQkxFX0hFQURFUl9DRUxMXSxcbiAgICBfYSQxW2V4cG9ydHMuQkxPQ0tTLlRBQkxFX0NFTExdID0gW2V4cG9ydHMuQkxPQ0tTLlBBUkFHUkFQSCwgZXhwb3J0cy5CTE9DS1MuVUxfTElTVCwgZXhwb3J0cy5CTE9DS1MuT0xfTElTVF0sXG4gICAgX2EkMVtleHBvcnRzLkJMT0NLUy5UQUJMRV9IRUFERVJfQ0VMTF0gPSBbZXhwb3J0cy5CTE9DS1MuUEFSQUdSQVBIXSxcbiAgICBfYSQxKTtcbi8qKlxuICogQXJyYXkgb2YgYWxsIGhlYWRpbmcgbGV2ZWxzXG4gKi9cbnZhciBIRUFESU5HUyA9IFtcbiAgICBleHBvcnRzLkJMT0NLUy5IRUFESU5HXzEsXG4gICAgZXhwb3J0cy5CTE9DS1MuSEVBRElOR18yLFxuICAgIGV4cG9ydHMuQkxPQ0tTLkhFQURJTkdfMyxcbiAgICBleHBvcnRzLkJMT0NLUy5IRUFESU5HXzQsXG4gICAgZXhwb3J0cy5CTE9DS1MuSEVBRElOR181LFxuICAgIGV4cG9ydHMuQkxPQ0tTLkhFQURJTkdfNixcbl07XG4vKipcbiAqIEFycmF5IG9mIGFsbCBibG9jayB0eXBlcyB0aGF0IG1heSBjb250YWluIHRleHQgYW5kIGlubGluZSBub2Rlcy5cbiAqL1xudmFyIFRFWFRfQ09OVEFJTkVSUyA9IF9fc3ByZWFkQXJyYXkoW2V4cG9ydHMuQkxPQ0tTLlBBUkFHUkFQSF0sIEhFQURJTkdTLCB0cnVlKTtcbi8qKlxuICogTm9kZSB0eXBlcyBiZWZvcmUgYHRhYmxlc2AgcmVsZWFzZS5cbiAqL1xudmFyIFYxX05PREVfVFlQRVMgPSBbXG4gICAgZXhwb3J0cy5CTE9DS1MuRE9DVU1FTlQsXG4gICAgZXhwb3J0cy5CTE9DS1MuUEFSQUdSQVBILFxuICAgIGV4cG9ydHMuQkxPQ0tTLkhFQURJTkdfMSxcbiAgICBleHBvcnRzLkJMT0NLUy5IRUFESU5HXzIsXG4gICAgZXhwb3J0cy5CTE9DS1MuSEVBRElOR18zLFxuICAgIGV4cG9ydHMuQkxPQ0tTLkhFQURJTkdfNCxcbiAgICBleHBvcnRzLkJMT0NLUy5IRUFESU5HXzUsXG4gICAgZXhwb3J0cy5CTE9DS1MuSEVBRElOR182LFxuICAgIGV4cG9ydHMuQkxPQ0tTLk9MX0xJU1QsXG4gICAgZXhwb3J0cy5CTE9DS1MuVUxfTElTVCxcbiAgICBleHBvcnRzLkJMT0NLUy5MSVNUX0lURU0sXG4gICAgZXhwb3J0cy5CTE9DS1MuSFIsXG4gICAgZXhwb3J0cy5CTE9DS1MuUVVPVEUsXG4gICAgZXhwb3J0cy5CTE9DS1MuRU1CRURERURfRU5UUlksXG4gICAgZXhwb3J0cy5CTE9DS1MuRU1CRURERURfQVNTRVQsXG4gICAgZXhwb3J0cy5JTkxJTkVTLkhZUEVSTElOSyxcbiAgICBleHBvcnRzLklOTElORVMuRU5UUllfSFlQRVJMSU5LLFxuICAgIGV4cG9ydHMuSU5MSU5FUy5BU1NFVF9IWVBFUkxJTkssXG4gICAgZXhwb3J0cy5JTkxJTkVTLkVNQkVEREVEX0VOVFJZLFxuICAgICd0ZXh0Jyxcbl07XG4vKipcbiAqIE1hcmtzIGJlZm9yZSBgc3VwZXJzY3JpcHRgICYgYHN1YnNjcmlwdGAgcmVsZWFzZS5cbiAqL1xudmFyIFYxX01BUktTID0gW2V4cG9ydHMuTUFSS1MuQk9MRCwgZXhwb3J0cy5NQVJLUy5DT0RFLCBleHBvcnRzLk1BUktTLklUQUxJQywgZXhwb3J0cy5NQVJLUy5VTkRFUkxJTkVdO1xuXG4vKipcbiAqIEEgcmljaCB0ZXh0IGRvY3VtZW50IGNvbnNpZGVyZWQgdG8gYmUgZW1wdHkuXG4gKiBBbnkgb3RoZXIgZG9jdW1lbnQgc3RydWN0dXJlIHRoYW4gdGhpcyBpcyBub3QgY29uc2lkZXJlZCBlbXB0eS5cbiAqL1xudmFyIEVNUFRZX0RPQ1VNRU5UID0ge1xuICAgIG5vZGVUeXBlOiBleHBvcnRzLkJMT0NLUy5ET0NVTUVOVCxcbiAgICBkYXRhOiB7fSxcbiAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5vZGVUeXBlOiBleHBvcnRzLkJMT0NLUy5QQVJBR1JBUEgsXG4gICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbWFya3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxufTtcblxuLyoqXG4gKiBUaW55IHJlcGxhY2VtZW50IGZvciBPYmplY3QudmFsdWVzKG9iamVjdCkuaW5jbHVkZXMoa2V5KSB0b1xuICogYXZvaWQgaW5jbHVkaW5nIENvcmVKUyBwb2x5ZmlsbHNcbiAqL1xuZnVuY3Rpb24gaGFzVmFsdWUob2JqLCB2YWx1ZSkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhvYmopOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICBpZiAodmFsdWUgPT09IG9ialtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBhbiBpbnN0YW5jZSBvZiBJbmxpbmUuXG4gKi9cbmZ1bmN0aW9uIGlzSW5saW5lKG5vZGUpIHtcbiAgICByZXR1cm4gaGFzVmFsdWUoZXhwb3J0cy5JTkxJTkVTLCBub2RlLm5vZGVUeXBlKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIGFuIGluc3RhbmNlIG9mIEJsb2NrLlxuICovXG5mdW5jdGlvbiBpc0Jsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gaGFzVmFsdWUoZXhwb3J0cy5CTE9DS1MsIG5vZGUubm9kZVR5cGUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYW4gaW5zdGFuY2Ugb2YgVGV4dC5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gJ3RleHQnO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBwYXJhZ3JhcGggaXMgZW1wdHkgKGhhcyBvbmx5IG9uZSBjaGlsZCBhbmQgdGhhdCBjaGlsZCBpcyBhbiBlbXB0eSBzdHJpbmcgdGV4dCBub2RlKVxuICovXG5mdW5jdGlvbiBpc0VtcHR5UGFyYWdyYXBoKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gZXhwb3J0cy5CTE9DS1MuUEFSQUdSQVBIKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY29udGVudC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmNvbnRlbnRbMF07XG4gICAgcmV0dXJuIHRleHROb2RlLm5vZGVUeXBlID09PSAndGV4dCcgJiYgdGV4dE5vZGUudmFsdWUgPT09ICcnO1xufVxuZnVuY3Rpb24gaXNWYWxpZERvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIChkb2N1bWVudCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2NvbnRlbnQnIGluIGRvY3VtZW50ICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoZG9jdW1lbnQuY29udGVudCkpO1xufVxudmFyIE1JTl9OT0RFU19GT1JfU1RSSVBQSU5HID0gMjtcbi8qKlxuICogU3RyaXBzIGVtcHR5IHRyYWlsaW5nIHBhcmFncmFwaCBmcm9tIGEgZG9jdW1lbnQgaWYgZW5hYmxlZFxuICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIHJpY2ggdGV4dCBkb2N1bWVudCB0byBwcm9jZXNzXG4gKiBAcmV0dXJucyBBIG5ldyBkb2N1bWVudCB3aXRoIHRoZSBlbXB0eSB0cmFpbGluZyBwYXJhZ3JhcGggcmVtb3ZlZCAoaWYgY29uZGl0aW9ucyBhcmUgbWV0KVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHByb2Nlc3NlZERvYyA9IHN0cmlwRW1wdHlUcmFpbGluZ1BhcmFncmFwaEZyb21Eb2N1bWVudChkb2N1bWVudCk7XG4gKi9cbmZ1bmN0aW9uIHN0cmlwRW1wdHlUcmFpbGluZ1BhcmFncmFwaEZyb21Eb2N1bWVudChkb2N1bWVudCkge1xuICAgIGlmICghaXNWYWxpZERvY3VtZW50KGRvY3VtZW50KSB8fCBkb2N1bWVudC5jb250ZW50Lmxlbmd0aCA8IE1JTl9OT0RFU19GT1JfU1RSSVBQSU5HKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gICAgdmFyIGxhc3ROb2RlID0gZG9jdW1lbnQuY29udGVudFtkb2N1bWVudC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgIC8vIENoZWNrIGlmIHRoZSBsYXN0IG5vZGUgaXMgYW4gZW1wdHkgcGFyYWdyYXBoXG4gICAgaWYgKGlzRW1wdHlQYXJhZ3JhcGgobGFzdE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG9jdW1lbnQpLCB7IGNvbnRlbnQ6IGRvY3VtZW50LmNvbnRlbnQuc2xpY2UoMCwgLTEpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZG9jdW1lbnQ7XG59XG5cbnZhciBoZWxwZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlzQmxvY2s6IGlzQmxvY2ssXG4gIGlzRW1wdHlQYXJhZ3JhcGg6IGlzRW1wdHlQYXJhZ3JhcGgsXG4gIGlzSW5saW5lOiBpc0lubGluZSxcbiAgaXNUZXh0OiBpc1RleHQsXG4gIHN0cmlwRW1wdHlUcmFpbGluZ1BhcmFncmFwaEZyb21Eb2N1bWVudDogc3RyaXBFbXB0eVRyYWlsaW5nUGFyYWdyYXBoRnJvbURvY3VtZW50XG59KTtcblxudmFyIHR5cGVNaXNtYXRjaEVycm9yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBhdGggPSBfYS5wYXRoLCBwcm9wZXJ0eSA9IF9hLnByb3BlcnR5LCB0eXBlTmFtZSA9IF9hLnR5cGVOYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRldGFpbHM6IFwiVGhlIHR5cGUgb2YgXFxcIlwiLmNvbmNhdChwcm9wZXJ0eSwgXCJcXFwiIGlzIGluY29ycmVjdCwgZXhwZWN0ZWQgdHlwZTogXCIpLmNvbmNhdCh0eXBlTmFtZSksXG4gICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAgcGF0aDogcGF0aC50b0FycmF5KCksXG4gICAgICAgIHR5cGU6IHR5cGVOYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgfTtcbn07XG52YXIgbWluU2l6ZUVycm9yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG1pbiA9IF9hLm1pbiwgdmFsdWUgPSBfYS52YWx1ZSwgcGF0aCA9IF9hLnBhdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3NpemUnLFxuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgcGF0aDogcGF0aC50b0FycmF5KCksXG4gICAgICAgIGRldGFpbHM6IFwiU2l6ZSBtdXN0IGJlIGF0IGxlYXN0IFwiLmNvbmNhdChtaW4pLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgfTtcbn07XG52YXIgbWF4U2l6ZUVycm9yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG1heCA9IF9hLm1heCwgdmFsdWUgPSBfYS52YWx1ZSwgcGF0aCA9IF9hLnBhdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3NpemUnLFxuICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgcGF0aDogcGF0aC50b0FycmF5KCksXG4gICAgICAgIGRldGFpbHM6IFwiU2l6ZSBtdXN0IGJlIGF0IG1vc3QgXCIuY29uY2F0KG1heCksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICB9O1xufTtcbnZhciBlbnVtRXJyb3IgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZXhwZWN0ZWQgPSBfYS5leHBlY3RlZCwgdmFsdWUgPSBfYS52YWx1ZSwgcGF0aCA9IF9hLnBhdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGV0YWlsczogXCJWYWx1ZSBtdXN0IGJlIG9uZSBvZiBleHBlY3RlZCB2YWx1ZXNcIixcbiAgICAgICAgbmFtZTogJ2luJyxcbiAgICAgICAgZXhwZWN0ZWQ6IF9fc3ByZWFkQXJyYXkoW10sIGV4cGVjdGVkLCB0cnVlKS5zb3J0KCksXG4gICAgICAgIHBhdGg6IHBhdGgudG9BcnJheSgpLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgfTtcbn07XG52YXIgdW5rbm93blByb3BlcnR5RXJyb3IgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBfYS5wcm9wZXJ0eSwgcGF0aCA9IF9hLnBhdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGV0YWlsczogXCJUaGUgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChwcm9wZXJ0eSwgXCJcXFwiIGlzIG5vdCBleHBlY3RlZFwiKSxcbiAgICAgICAgbmFtZTogJ3VuZXhwZWN0ZWQnLFxuICAgICAgICBwYXRoOiBwYXRoLnRvQXJyYXkoKSxcbiAgICB9O1xufTtcbnZhciByZXF1aXJlZFByb3BlcnR5RXJyb3IgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBfYS5wcm9wZXJ0eSwgcGF0aCA9IF9hLnBhdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGV0YWlsczogXCJUaGUgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChwcm9wZXJ0eSwgXCJcXFwiIGlzIHJlcXVpcmVkIGhlcmVcIiksXG4gICAgICAgIG5hbWU6ICdyZXF1aXJlZCcsXG4gICAgICAgIHBhdGg6IHBhdGgudG9BcnJheSgpLFxuICAgIH07XG59O1xuXG52YXIgT2JqZWN0QXNzZXJ0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9iamVjdEFzc2VydGlvbihvYmosIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmNhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBlcnJvcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IF90aGlzLl9lcnJvcnMpLnB1c2guYXBwbHkoX2EsIGVycm9ycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NlcnRzIHRoZSBrZXkgZXhpc3RzIGluIHRoZSBvYmplY3QuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgY2FsbCB0aGlzXG4gICAgICAgICAqIGZ1bmN0aW9uIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2UgYCQub2JqZWN0YCwgYCQubnVtYmVyYCwgYCQuc3RyaW5nYCwgZXRjLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leGlzdHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIF90aGlzLm9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY2F0Y2gocmVxdWlyZWRQcm9wZXJ0eUVycm9yKHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eToga2V5LFxuICAgICAgICAgICAgICAgIHBhdGg6IF90aGlzLnBhdGgub2Yoa2V5KSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2VydHMgdGhlIGtleSBleGlzdHMgaW4gdGhlIG9iamVjdCBhbmQgaXRzIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LiBpZlxuICAgICAgICAgKiBubyBrZXkgaXMgcHJvdmlkZWQsIGl0IGFzc2VydHMgdGhlIG9iamVjdCBpdHNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9iamVjdCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtleSA/IF90aGlzLm9ialtrZXldIDogX3RoaXMub2JqO1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZXhpc3RzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhdGggPSBrZXkgPyBfdGhpcy5wYXRoLm9mKGtleSkgOiBfdGhpcy5wYXRoO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gKF9hID0ga2V5ICE9PSBudWxsICYmIGtleSAhPT0gdm9pZCAwID8ga2V5IDogX3RoaXMucGF0aC5sYXN0KCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd2YWx1ZSc7XG4gICAgICAgICAgICBfdGhpcy5jYXRjaCh0eXBlTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6ICdPYmplY3QnLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2VydHMgdGhlIGtleSBleGlzdHMgaW4gdGhlIG9iamVjdCBhbmQgaXRzIHZhbHVlIGlzIGEgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHJpbmcgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5vYmpba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgJiYgIV90aGlzLmV4aXN0cyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNhdGNoKHR5cGVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogJ1N0cmluZycsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IGtleSxcbiAgICAgICAgICAgICAgICBwYXRoOiBfdGhpcy5wYXRoLm9mKGtleSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNzZXJ0cyB0aGUga2V5IGV4aXN0cyBpbiB0aGUgb2JqZWN0IGFuZCBpdHMgdmFsdWUgaXMgYSBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm51bWJlciA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbmFsKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5vYmpba2V5XTtcbiAgICAgICAgICAgIGlmIChvcHRpb25hbCAmJiAhKGtleSBpbiBfdGhpcy5vYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLmV4aXN0cyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNhdGNoKHR5cGVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogJ051bWJlcicsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IGtleSxcbiAgICAgICAgICAgICAgICBwYXRoOiBfdGhpcy5wYXRoLm9mKGtleSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNzZXJ0cyB0aGUga2V5IGV4aXN0cyBpbiB0aGUgb2JqZWN0IGFuZCBpdHMgdmFsdWUgaXMgYW4gYXJyYXkuIFlvdSBkb24ndFxuICAgICAgICAgKiBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgdGhpcyBmdW5jdGlvbiBiZWZvcmUgYCQuZWFjaGAgb3IgYCQubWF4TGVuZ3RoYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXJyYXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5vYmpba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgJiYgIV90aGlzLmV4aXN0cyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jYXRjaCh0eXBlTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6ICdBcnJheScsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IGtleSxcbiAgICAgICAgICAgICAgICBwYXRoOiBfdGhpcy5wYXRoLm9mKGtleSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNzZXJ0cyB0aGUgdmFsdWUgb2YgdGhlIGtleSBpcyBvbmUgb2YgdGhlIGV4cGVjdGVkIHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW51bSA9IGZ1bmN0aW9uIChrZXksIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5vYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGV4cGVjdGVkLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY2F0Y2goZW51bUVycm9yKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBhdGg6IF90aGlzLnBhdGgub2Yoa2V5KSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2VydHMgdGhlIGFycmF5IHZhbHVlIG9mIHRoZSBvYmplY3Qga2V5IGlzIGVtcHR5LiBJZiB0aGUgdmFsdWUgaXNuJ3QgYW5cbiAgICAgICAgICogYXJyYXksIHRoZSBmdW5jdGlvbiBjYXB0dXJlcyBhIHR5cGUgZXJyb3IgYW5kIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtcHR5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5hcnJheShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMub2JqW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jYXRjaChtYXhTaXplRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1heDogMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcGF0aDogX3RoaXMucGF0aC5vZihrZXkpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNzZXJ0cyB0aGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZSBvZiB0aGUgb2JqZWN0IGtleSBpcyBhdCBsZWFzdCBgbWluYC4gSWYgdGhlXG4gICAgICAgICAqIHZhbHVlIGlzbid0IGFuIGFycmF5LCB0aGUgZnVuY3Rpb24gY2FwdHVyZXMgYSB0eXBlIGVycm9yIGFuZCByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5MZW5ndGggPSBmdW5jdGlvbiAoa2V5LCBtaW4pIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuYXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLm9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSBtaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNhdGNoKG1pblNpemVFcnJvcih7XG4gICAgICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHBhdGg6IF90aGlzLnBhdGgub2Yoa2V5KSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2VydHMgdGhlIG9iamVjdCBoYXMgbm8gYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG90aGVyIHRoYW4gdGhlIG9uZXNcbiAgICAgICAgICogc3BlY2lmaWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vQWRkaXRpb25hbFByb3BlcnRpZXMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIHVua25vd25zID0gT2JqZWN0LmtleXMoX3RoaXMub2JqKVxuICAgICAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFwcm9wZXJ0aWVzLmluY2x1ZGVzKGtleSk7IH0pO1xuICAgICAgICAgICAgdW5rbm93bnMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2F0Y2godW5rbm93blByb3BlcnR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IF90aGlzLnBhdGgub2YocHJvcGVydHkpLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHVua25vd25zLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIHZhbHVlIG9mIHRoZSBrZXkgYW5kIGFzc2VydCBlYWNoIGl0ZW0uIElmIHRoZSB2YWx1ZSBpc24ndFxuICAgICAgICAgKiBhbiBhcnJheSwgdGhlIGZ1bmN0aW9uIGNhcHR1cmVzIGEgdHlwZSBlcnJvciBhbmQgc2FmZWx5IGV4aXRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgaW1wbGVtZW50YXRpb24sIHdlIHN0b3AgZWFybHkgaWYgd2VcbiAgICAgICAgICogZmluZCBhbnkgZXJyb3JzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lYWNoID0gZnVuY3Rpb24gKGtleSwgYXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmFycmF5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5vYmpba2V5XTtcbiAgICAgICAgICAgIHZhciBmb3VuZEVycm9ycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gYXNzZXJ0KGl0ZW0sIF90aGlzLnBhdGgub2Yoa2V5KS5vZihpbmRleCkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEVycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmNhdGNoLmFwcGx5KF90aGlzLCBlcnJvcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RBc3NlcnRpb24ucHJvdG90eXBlLCBcImVycm9yc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLmRldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGVycm9yLnBhdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZXJyb3JzLmZpbmRJbmRleChmdW5jdGlvbiAoc3RlcCkgeyByZXR1cm4gc2VyaWFsaXplRXJyb3IoZXJyb3IpID09PSBzZXJpYWxpemVFcnJvcihzdGVwKTsgfSkgPT09IGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0QXNzZXJ0aW9uO1xufSgpKTtcblxudmFyIFZPSURfQ09OVEVOVCA9IFtdO1xudmFyIE5vZGVBc3NlcnRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZUFzc2VydGlvbihjb250ZW50UnVsZSwgdmFsaWRhdGVEYXRhKSB7XG4gICAgICAgIHRoaXMuY29udGVudFJ1bGUgPSBjb250ZW50UnVsZTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZURhdGEgPSB2YWxpZGF0ZURhdGE7XG4gICAgfVxuICAgIE5vZGVBc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCA9IGZ1bmN0aW9uIChub2RlLCBwYXRoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciAkID0gbmV3IE9iamVjdEFzc2VydGlvbihub2RlLCBwYXRoKTtcbiAgICAgICAgaWYgKCEkLm9iamVjdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5lcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgJC5ub0FkZGl0aW9uYWxQcm9wZXJ0aWVzKFsnbm9kZVR5cGUnLCAnZGF0YScsICdjb250ZW50J10pO1xuICAgICAgICB2YXIgX2MgPSBBcnJheS5pc0FycmF5KHRoaXMuY29udGVudFJ1bGUpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBub2RlVHlwZXM6IHRoaXMuY29udGVudFJ1bGUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHRoaXMuY29udGVudFJ1bGUobm9kZSwgcGF0aCksIG5vZGVUeXBlcyA9IF9jLm5vZGVUeXBlcywgX2QgPSBfYy5taW4sIG1pbiA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gICAgICAgIGlmIChub2RlVHlwZXMubGVuZ3RoID09PSAwICYmIG1pbiA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29udGVudCBydWxlLiBDYW5ub3QgaGF2ZSBlbmZvcmNlIGEgJ21pbicgb2YgXCIuY29uY2F0KG1pbiwgXCIgd2l0aCBubyBub2RlVHlwZXNcIikpO1xuICAgICAgICB9XG4gICAgICAgICQubWluTGVuZ3RoKCdjb250ZW50JywgbWluKTtcbiAgICAgICAgLy8gSXMgdm9pZFxuICAgICAgICBpZiAobm9kZVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgJC5lbXB0eSgnY29udGVudCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBjb250ZW50IG5vZGVzIGhhdmUgdmFsaWQgbm9kZVR5cGVzIHdpdGhvdXQgdmFsaWRhdGluZyB0aGUgZnVsbFxuICAgICAgICAvLyBzaGFwZSB3aGljaCBpcyBzb21ldGhpbmcgdGhhdCdzIG9ubHkgZG9uZSBsYXRlciBpZiB0aGUgY3VycmVudCBub2RlIGlzXG4gICAgICAgIC8vIHZhbGlkLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQuZWFjaCgnY29udGVudCcsIGZ1bmN0aW9uIChpdGVtLCBwYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0kID0gbmV3IE9iamVjdEFzc2VydGlvbihpdGVtLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0kLm9iamVjdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtJC5lcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0kLmVudW0oJ25vZGVUeXBlJywgbm9kZVR5cGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSQuZXJyb3JzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQub2JqZWN0KCdkYXRhJykpIHtcbiAgICAgICAgICAgIHZhciBkYXRhRXJyb3JzID0gKF9iID0gKF9hID0gdGhpcy52YWxpZGF0ZURhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIG5vZGUuZGF0YSwgcGF0aC5vZignZGF0YScpKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgICAgICAkLmNhdGNoLmFwcGx5KCQsIGRhdGFFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkLmVycm9ycztcbiAgICB9O1xuICAgIHJldHVybiBOb2RlQXNzZXJ0aW9uO1xufSgpKTtcbnZhciBFbnRpdHlMaW5rQXNzZXJ0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbnRpdHlMaW5rQXNzZXJ0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVudGl0eUxpbmtBc3NlcnRpb24obGlua1R5cGUsIGNvbnRlbnROb2RlVHlwZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGVudE5vZGVUeXBlcywgZnVuY3Rpb24gKGRhdGEsIHBhdGgpIHsgcmV0dXJuIF90aGlzLmFzc2VydExpbmsoZGF0YSwgcGF0aCk7IH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxpbmtUeXBlID0gbGlua1R5cGU7XG4gICAgICAgIF90aGlzLmFzc2VydExpbmsgPSBmdW5jdGlvbiAoZGF0YSwgcGF0aCkge1xuICAgICAgICAgICAgdmFyICQgPSBuZXcgT2JqZWN0QXNzZXJ0aW9uKGRhdGEsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKCQub2JqZWN0KCd0YXJnZXQnKSkge1xuICAgICAgICAgICAgICAgIHZhciBzeXMkID0gbmV3IE9iamVjdEFzc2VydGlvbihkYXRhLnRhcmdldC5zeXMsIHBhdGgub2YoJ3RhcmdldCcpLm9mKCdzeXMnKSk7XG4gICAgICAgICAgICAgICAgaWYgKHN5cyQub2JqZWN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3lzJC5lbnVtKCd0eXBlJywgW190aGlzLnR5cGVdKTtcbiAgICAgICAgICAgICAgICAgICAgc3lzJC5lbnVtKCdsaW5rVHlwZScsIFtfdGhpcy5saW5rVHlwZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHlwZSA9PT0gJ0xpbmsnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeXMkLnN0cmluZygnaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5cyQubm9BZGRpdGlvbmFsUHJvcGVydGllcyhbJ3R5cGUnLCAnbGlua1R5cGUnLCAnaWQnXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMudHlwZSA9PT0gJ1Jlc291cmNlTGluaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5cyQuc3RyaW5nKCd1cm4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5cyQubm9BZGRpdGlvbmFsUHJvcGVydGllcyhbJ3R5cGUnLCAnbGlua1R5cGUnLCAndXJuJ10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQuY2F0Y2guYXBwbHkoJCwgc3lzJC5lcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJC5ub0FkZGl0aW9uYWxQcm9wZXJ0aWVzKFsndGFyZ2V0J10pO1xuICAgICAgICAgICAgcmV0dXJuICQuZXJyb3JzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50eXBlID0gX3RoaXMubGlua1R5cGUuc3RhcnRzV2l0aCgnQ29udGVudGZ1bDonKSA/ICdSZXNvdXJjZUxpbmsnIDogJ0xpbmsnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFbnRpdHlMaW5rQXNzZXJ0aW9uO1xufShOb2RlQXNzZXJ0aW9uKSk7XG52YXIgSHlwZXJMaW5rQXNzZXJ0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIeXBlckxpbmtBc3NlcnRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHlwZXJMaW5rQXNzZXJ0aW9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBbJ3RleHQnXSwgZnVuY3Rpb24gKGRhdGEsIHBhdGgpIHsgcmV0dXJuIF90aGlzLmFzc2VydExpbmsoZGF0YSwgcGF0aCk7IH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFzc2VydExpbmsgPSBmdW5jdGlvbiAoZGF0YSwgcGF0aCkge1xuICAgICAgICAgICAgdmFyICQgPSBuZXcgT2JqZWN0QXNzZXJ0aW9uKGRhdGEsIHBhdGgpO1xuICAgICAgICAgICAgJC5zdHJpbmcoJ3VyaScpO1xuICAgICAgICAgICAgJC5ub0FkZGl0aW9uYWxQcm9wZXJ0aWVzKFsndXJpJ10pO1xuICAgICAgICAgICAgcmV0dXJuICQuZXJyb3JzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIeXBlckxpbmtBc3NlcnRpb247XG59KE5vZGVBc3NlcnRpb24pKTtcbnZhciBhc3NlcnQgPSBmdW5jdGlvbiAoY29udGVudFJ1bGUsIHZhbGlkYXRlRGF0YSkge1xuICAgIHJldHVybiBuZXcgTm9kZUFzc2VydGlvbihjb250ZW50UnVsZSwgdmFsaWRhdGVEYXRhKTtcbn07XG52YXIgYXNzZXJ0TGluayA9IGZ1bmN0aW9uIChsaW5rVHlwZSwgY29udGVudFJ1bGUpIHtcbiAgICByZXR1cm4gbmV3IEVudGl0eUxpbmtBc3NlcnRpb24obGlua1R5cGUsIGNvbnRlbnRSdWxlKTtcbn07XG5cbnZhciBQYXRoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLm9mID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0aChfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF90aGlzLnBhdGgsIHRydWUpLCBbZWxlbWVudF0sIGZhbHNlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBhdGgubGVuZ3RoID09PSAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucGF0aFtfdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucGF0aDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFBhdGg7XG59KCkpO1xuXG5mdW5jdGlvbiBhc3NlcnRUZXh0KHRleHQsIHBhdGgpIHtcbiAgICB2YXIgJCA9IG5ldyBPYmplY3RBc3NlcnRpb24odGV4dCwgcGF0aCk7XG4gICAgaWYgKCEkLm9iamVjdCgpKSB7XG4gICAgICAgIHJldHVybiAkLmVycm9ycztcbiAgICB9XG4gICAgJC5ub0FkZGl0aW9uYWxQcm9wZXJ0aWVzKFsnbm9kZVR5cGUnLCAnZGF0YScsICd2YWx1ZScsICdtYXJrcyddKTtcbiAgICAkLm9iamVjdCgnZGF0YScpO1xuICAgICQuZWFjaCgnbWFya3MnLCBmdW5jdGlvbiAobWFyaywgcGF0aCkge1xuICAgICAgICB2YXIgbWFyayQgPSBuZXcgT2JqZWN0QXNzZXJ0aW9uKG1hcmssIHBhdGgpO1xuICAgICAgICBpZiAoIW1hcmskLm9iamVjdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFyayQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHdlIGRvbid0IGV4cGxpY2l0bHkgY2hlY2sgZm9yIHN1cHBvcnRlZCBtYXJrc1xuICAgICAgICAvLyBlLmcuIGJvbGQsIGl0YWxpYyAuLmV0Yy4gVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgYSBjdXN0b21lciB0byBhZGRcbiAgICAgICAgLy8gY3VzdG9tIG1hcmtzXG4gICAgICAgIG1hcmskLnN0cmluZygndHlwZScpO1xuICAgICAgICByZXR1cm4gbWFyayQuZXJyb3JzO1xuICAgIH0pO1xuICAgICQuc3RyaW5nKCd2YWx1ZScpO1xuICAgIHJldHVybiAkLmVycm9ycztcbn1cblxudmFyIF9hO1xudmFyIGFzc2VydElubGluZU9yVGV4dCA9IGFzc2VydChfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIE9iamVjdC52YWx1ZXMoZXhwb3J0cy5JTkxJTkVTKSwgdHJ1ZSksIFsndGV4dCddLCBmYWxzZSkuc29ydCgpKTtcbnZhciBhc3NlcnRMaXN0ID0gYXNzZXJ0KFtleHBvcnRzLkJMT0NLUy5MSVNUX0lURU1dKTtcbnZhciBhc3NlcnRWb2lkRW50cnlMaW5rID0gYXNzZXJ0TGluaygnRW50cnknLCBWT0lEX0NPTlRFTlQpO1xudmFyIGFzc2VydFRhYmxlQ2VsbCA9IGFzc2VydChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIG5vZGVUeXBlczogW2V4cG9ydHMuQkxPQ0tTLlBBUkFHUkFQSF0sXG4gICAgbWluOiAxLFxufSk7IH0sIGZ1bmN0aW9uIChkYXRhLCBwYXRoKSB7XG4gICAgdmFyICQgPSBuZXcgT2JqZWN0QXNzZXJ0aW9uKGRhdGEsIHBhdGgpO1xuICAgICQubm9BZGRpdGlvbmFsUHJvcGVydGllcyhbJ2NvbHNwYW4nLCAncm93c3BhbiddKTtcbiAgICAkLm51bWJlcignY29sc3BhbicsIHRydWUpO1xuICAgICQubnVtYmVyKCdyb3dzcGFuJywgdHJ1ZSk7XG4gICAgcmV0dXJuICQuZXJyb3JzO1xufSk7XG52YXIgbm9kZVZhbGlkYXRvciA9IChfYSA9IHt9LFxuICAgIF9hW2V4cG9ydHMuQkxPQ0tTLkRPQ1VNRU5UXSA9IGFzc2VydChUT1BfTEVWRUxfQkxPQ0tTKSxcbiAgICBfYVtleHBvcnRzLkJMT0NLUy5QQVJBR1JBUEhdID0gYXNzZXJ0SW5saW5lT3JUZXh0LFxuICAgIF9hW2V4cG9ydHMuQkxPQ0tTLkhFQURJTkdfMV0gPSBhc3NlcnRJbmxpbmVPclRleHQsXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuSEVBRElOR18yXSA9IGFzc2VydElubGluZU9yVGV4dCxcbiAgICBfYVtleHBvcnRzLkJMT0NLUy5IRUFESU5HXzNdID0gYXNzZXJ0SW5saW5lT3JUZXh0LFxuICAgIF9hW2V4cG9ydHMuQkxPQ0tTLkhFQURJTkdfNF0gPSBhc3NlcnRJbmxpbmVPclRleHQsXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuSEVBRElOR181XSA9IGFzc2VydElubGluZU9yVGV4dCxcbiAgICBfYVtleHBvcnRzLkJMT0NLUy5IRUFESU5HXzZdID0gYXNzZXJ0SW5saW5lT3JUZXh0LFxuICAgIF9hW2V4cG9ydHMuQkxPQ0tTLlFVT1RFXSA9IGFzc2VydChDT05UQUlORVJTW2V4cG9ydHMuQkxPQ0tTLlFVT1RFXSksXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuRU1CRURERURfRU5UUlldID0gYXNzZXJ0Vm9pZEVudHJ5TGluayxcbiAgICBfYVtleHBvcnRzLkJMT0NLUy5FTUJFRERFRF9BU1NFVF0gPSBhc3NlcnRMaW5rKCdBc3NldCcsIFZPSURfQ09OVEVOVCksXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuRU1CRURERURfUkVTT1VSQ0VdID0gYXNzZXJ0TGluaygnQ29udGVudGZ1bDpFbnRyeScsIFZPSURfQ09OVEVOVCksXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuSFJdID0gYXNzZXJ0KFZPSURfQ09OVEVOVCksXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuT0xfTElTVF0gPSBhc3NlcnRMaXN0LFxuICAgIF9hW2V4cG9ydHMuQkxPQ0tTLlVMX0xJU1RdID0gYXNzZXJ0TGlzdCxcbiAgICBfYVtleHBvcnRzLkJMT0NLUy5MSVNUX0lURU1dID0gYXNzZXJ0KF9fc3ByZWFkQXJyYXkoW10sIExJU1RfSVRFTV9CTE9DS1MsIHRydWUpLnNvcnQoKSksXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuVEFCTEVdID0gYXNzZXJ0KGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgIG5vZGVUeXBlczogW2V4cG9ydHMuQkxPQ0tTLlRBQkxFX1JPV10sXG4gICAgICAgIG1pbjogMSxcbiAgICB9KTsgfSksXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuVEFCTEVfUk9XXSA9IGFzc2VydChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICBub2RlVHlwZXM6IFtleHBvcnRzLkJMT0NLUy5UQUJMRV9DRUxMLCBleHBvcnRzLkJMT0NLUy5UQUJMRV9IRUFERVJfQ0VMTF0sXG4gICAgICAgIG1pbjogMSxcbiAgICB9KTsgfSksXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuVEFCTEVfQ0VMTF0gPSBhc3NlcnRUYWJsZUNlbGwsXG4gICAgX2FbZXhwb3J0cy5CTE9DS1MuVEFCTEVfSEVBREVSX0NFTExdID0gYXNzZXJ0VGFibGVDZWxsLFxuICAgIF9hW2V4cG9ydHMuSU5MSU5FUy5IWVBFUkxJTktdID0gbmV3IEh5cGVyTGlua0Fzc2VydGlvbigpLFxuICAgIF9hW2V4cG9ydHMuSU5MSU5FUy5FTUJFRERFRF9FTlRSWV0gPSBhc3NlcnRWb2lkRW50cnlMaW5rLFxuICAgIF9hW2V4cG9ydHMuSU5MSU5FUy5FTUJFRERFRF9SRVNPVVJDRV0gPSBhc3NlcnRMaW5rKCdDb250ZW50ZnVsOkVudHJ5JywgVk9JRF9DT05URU5UKSxcbiAgICBfYVtleHBvcnRzLklOTElORVMuRU5UUllfSFlQRVJMSU5LXSA9IGFzc2VydExpbmsoJ0VudHJ5JywgWyd0ZXh0J10pLFxuICAgIF9hW2V4cG9ydHMuSU5MSU5FUy5BU1NFVF9IWVBFUkxJTktdID0gYXNzZXJ0TGluaygnQXNzZXQnLCBbJ3RleHQnXSksXG4gICAgX2FbZXhwb3J0cy5JTkxJTkVTLlJFU09VUkNFX0hZUEVSTElOS10gPSBhc3NlcnRMaW5rKCdDb250ZW50ZnVsOkVudHJ5JywgWyd0ZXh0J10pLFxuICAgIF9hKTtcbmZ1bmN0aW9uIHZhbGlkYXRlTm9kZShub2RlLCBwYXRoKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICByZXR1cm4gYXNzZXJ0VGV4dChub2RlLCBwYXRoKTtcbiAgICB9XG4gICAgdmFyIGVycm9ycyA9IG5vZGVWYWxpZGF0b3Jbbm9kZS5ub2RlVHlwZV0uYXNzZXJ0KG5vZGUsIHBhdGgpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICB2YXIgJCA9IG5ldyBPYmplY3RBc3NlcnRpb24obm9kZSwgcGF0aCk7XG4gICAgJC5lYWNoKCdjb250ZW50JywgZnVuY3Rpb24gKGl0ZW0sIHBhdGgpIHtcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBrbm93IHRob3NlIGFyZSB2YWxpZCBub2RlcyB0aGFua3MgdG8gdGhlIGFzc2VydGlvbiBkb25lIGluXG4gICAgICAgIC8vIHRoZSBOb2RlQXNzZXJ0aW9uIGNsYXNzXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZU5vZGUoaXRlbSwgcGF0aCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICQuZXJyb3JzO1xufVxudmFyIHZhbGlkYXRlUmljaFRleHREb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgIHZhciBwYXRoID0gbmV3IFBhdGgoKTtcbiAgICB2YXIgJCA9IG5ldyBPYmplY3RBc3NlcnRpb24oZG9jdW1lbnQsIHBhdGgpO1xuICAgIGlmICgkLm9iamVjdCgpKSB7XG4gICAgICAgICQuZW51bSgnbm9kZVR5cGUnLCBbZXhwb3J0cy5CTE9DS1MuRE9DVU1FTlRdKTtcbiAgICB9XG4gICAgaWYgKCQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuICQuZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVOb2RlKGRvY3VtZW50LCBwYXRoKTtcbn07XG5cbmV4cG9ydHMuQ09OVEFJTkVSUyA9IENPTlRBSU5FUlM7XG5leHBvcnRzLkVNUFRZX0RPQ1VNRU5UID0gRU1QVFlfRE9DVU1FTlQ7XG5leHBvcnRzLkhFQURJTkdTID0gSEVBRElOR1M7XG5leHBvcnRzLkxJU1RfSVRFTV9CTE9DS1MgPSBMSVNUX0lURU1fQkxPQ0tTO1xuZXhwb3J0cy5UQUJMRV9CTE9DS1MgPSBUQUJMRV9CTE9DS1M7XG5leHBvcnRzLlRFWFRfQ09OVEFJTkVSUyA9IFRFWFRfQ09OVEFJTkVSUztcbmV4cG9ydHMuVE9QX0xFVkVMX0JMT0NLUyA9IFRPUF9MRVZFTF9CTE9DS1M7XG5leHBvcnRzLlYxX01BUktTID0gVjFfTUFSS1M7XG5leHBvcnRzLlYxX05PREVfVFlQRVMgPSBWMV9OT0RFX1RZUEVTO1xuZXhwb3J0cy5WT0lEX0JMT0NLUyA9IFZPSURfQkxPQ0tTO1xuZXhwb3J0cy5oZWxwZXJzID0gaGVscGVycztcbmV4cG9ydHMudmFsaWRhdGVSaWNoVGV4dERvY3VtZW50ID0gdmFsaWRhdGVSaWNoVGV4dERvY3VtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@contentful/rich-text-types/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@contentful/rich-text-types/node_modules/is-plain-obj/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@contentful/rich-text-types/node_modules/is-plain-obj/index.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvbnRlbnRmdWwvcmljaC10ZXh0LXR5cGVzL25vZGVfbW9kdWxlcy9pcy1wbGFpbi1vYmovaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdXNlci9EZXNrdG9wL3BvcnRzbW91dGgvbm9kZV9tb2R1bGVzL0Bjb250ZW50ZnVsL3JpY2gtdGV4dC10eXBlcy9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZSA9PiB7XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@contentful/rich-text-types/node_modules/is-plain-obj/index.js\n");

/***/ })

};
;